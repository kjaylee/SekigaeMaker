<!DOCTYPE html>
<html>
  <head>
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@mdi/font@4.x/css/materialdesignicons.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.min.css" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
    <style>
      li {
        text-align: center;
        list-style: none;
        height: 80px;
      }
      .on-seats {
        background: mediumaquamarine;
      }
      .male-seats {
        background: lightskyblue;
      }
      .female-seats {
        background: plum;
      }
      .off-seats {
        background: gainsboro;
      }
      .seat{
        height: 80px;
        width: 80px;
        display: inline-block;
        border: 3px solid white;
        box-sizing: border-box;
        text-align: center;
      }
      [v-cloak] {
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="app" v-cloak>
      <v-app>
        <v-container fluid>
          <v-row>
            <!-- タイトル -->
            <v-col cols="12" style="background-color: wheat">
              <h1 class="text-center">席替えメーカー（実装17日目）</h1>
            </v-col>
          </v-row>

          <v-row>
            <!-- 座席テーブル -->
            <v-col cols="6" style="background-color: #c8fac8">
              <p style="text-align: center">名前を入力してください</p>
              <p style="text-align: center">現在の座席に名前を入力することで、全員移動させることもできます</p>
              <p style="text-align: center">クリックで性別を変更できます</p>
              <div id="seatArrange">
                <li v-for="( seats, indexRow ) in seatsTable">
                  <textarea v-for="( seat, indexCol ) in seats" :class="getColorByName(seatsTable[indexRow][indexCol])"
                  class="seat" @input="writeStudentName( indexCol, indexRow, $event.target.value ); countSeats();"
                  @input.once="pushSeatsTableIndex(indexCol, indexRow);"
                  :key="indexRow.toString() + indexCol.toString()" style="text-align: center;  resize: none; word-break: keep-all"
                  :value="seatsTable[indexRow][indexCol]" @click="toggleGender(indexCol,indexRow)">
                  </textarea>
                </li>
              </div>
            </v-col>

            <v-col cols="6">
              <v-row>
                <!-- 横の座席数入力フォーム -->
                <v-col cols="6" style="background-color: turquoise">
                  <v-select :items="seatsOptionsX" label="横の座席数" outlined　v-model.number="seatsSizeX"
                  @change="makeSeatsTable()" style="width:100px"></v-select>
                </v-col>

                <!-- 縦の座席数入力フォーム -->
                <v-col cols="6" style="background-color: lightseagreen">
                  <v-select :items="seatsOptionsY" label="縦の座席数" outlined　v-model.number="seatsSizeY"
                  @change="makeSeatsTable()" style="width:100px"></v-select>
                </v-col>

                <!-- 同じ席にしないかどうかのチェックボックス -->
                <v-col cols="12" style="background-color: orange">
                  <v-checkbox label="現在の座席と異なる座席にする" color="indigo darken-3" v-model="isAllDifferent"
                  hide-details></v-checkbox>
                  <v-checkbox label="男女の座席を固定する" color="indigo darken-3" v-model="isFixGender"
                  hide-details></v-checkbox>
                </v-col>

                <!-- 列で固定するエクスパンションパネル -->
                <v-col cols="12" style="background-color: hotpink">
                  <v-expansion-panels accordion>
                    <v-expansion-panel>
                      <v-expansion-panel-header>横の列で固定する</v-expansion-panel-header>
                      <v-expansion-panel-content>
                        <!-- ネストされたエクスパンションパネル -->
                        <v-expansion-panels accordion>
                          <!-- 最前列のエクスパンションパネル -->
                          <v-expansion-panel>
                            <v-expansion-panel-header>最前列</v-expansion-panel-header>
                            <v-expansion-panel-content>
                              <!-- 生徒の入力フォーム（初期表示のための１つ目） -->
                              <span>
                                <v-select :items="studentsName" placeholder="Aさん" outlined style="width:200px; display: inline-block"
                                @change="addFrontConditions"></v-select>
                              </span>
                              <!-- 生徒の入力フォーム（追加表示のための２つ目以降） -->
                              <span v-for="frontCondition in frontConditions">
                                <v-select :items="studentsName" placeholder="Aさん" outlined style="width:200px; display: inline-block"
                                @change="addFrontConditions"></v-select>
                              </span>
                            </v-expansion-panel-content>
                          </v-expansion-panel>

                          <!-- 前2列のエクスパンションパネル -->
                          <v-expansion-panel>
                            <v-expansion-panel-header>前2列</v-expansion-panel-header>
                            <v-expansion-panel-content>
                              <!-- 生徒の入力フォーム（初期表示のための１つ目） -->
                              <span>
                                <v-select :items="studentsName" placeholder="Aさん" outlined style="width:200px; display: inline-block"
                                @change="addFrontConditions"></v-select>
                              </span>
                              <!-- 生徒の入力フォーム（追加表示のための２つ目以降） -->
                              <span v-for="frontCondition in frontConditions">
                                <v-select :items="studentsName" placeholder="Aさん" outlined style="width:200px; display: inline-block"
                                @change="addFrontConditions"></v-select>
                              </span>
                            </v-expansion-panel-content>
                          </v-expansion-panel>

                          <!-- 後ろ2列のエクスパンションパネル -->
                          <v-expansion-panel>
                            <v-expansion-panel-header>後ろ2列</v-expansion-panel-header>
                            <v-expansion-panel-content>
                              <!-- 生徒の入力フォーム（初期表示のための１つ目） -->
                              <span>
                                <v-select :items="studentsName" placeholder="Aさん" outlined style="width:200px; display: inline-block"
                                @change="addFrontConditions"></v-select>
                              </span>
                              <!-- 生徒の入力フォーム（追加表示のための２つ目以降） -->
                              <span v-for="frontCondition in frontConditions">
                                <v-select :items="studentsName" placeholder="Aさん" outlined style="width:200px; display: inline-block"
                                @change="addFrontConditions"></v-select>
                              </span>
                            </v-expansion-panel-content>
                          </v-expansion-panel>

                          <!-- 最後列のエクスパンションパネル -->
                          <v-expansion-panel>
                            <v-expansion-panel-header>最後列</v-expansion-panel-header>
                            <v-expansion-panel-content>
                              <!-- 生徒の入力フォーム（初期表示のための１つ目） -->
                              <span>
                                <v-select :items="studentsName" placeholder="Aさん" outlined style="width:200px; display: inline-block"
                                @change="addFrontConditions"></v-select>
                              </span>
                              <!-- 生徒の入力フォーム（追加表示のための２つ目以降） -->
                              <span v-for="frontCondition in frontConditions">
                                <v-select :items="studentsName" placeholder="Aさん" outlined style="width:200px; display: inline-block"
                                @change="addFrontConditions"></v-select>
                              </span>
                            </v-expansion-panel-content>
                          </v-expansion-panel>

                        </v-expansion-panels>
                      </v-expansion-panel-content>
                    </v-expansion-panel>
                  </v-expansion-panels>
                </v-col>

                <!-- 近づける生徒のエクスパンションパネル -->
                <v-col cols="12" style="background-color: burlywood">
                  <v-expansion-panels accordion>
                    <v-expansion-panel>
                      <v-expansion-panel-header>生徒同士を近づける</v-expansion-panel-header>
                      <v-expansion-panel-content>
                        <!-- 近づける生徒の入力フォーム（初期表示のための１つ目） -->
                        <div>
                          <v-select :items="studentsName" placeholder="Aさん" outlined style="width:200px; display: inline-block"
                          @change="setNearConditionOption1"></v-select>
                          と
                          <v-select :items="studentsName" placeholder="Bさん" outlined style="width:200px; display: inline-block"
                          @change="setNearConditionOption2"></v-select>
                          の間を
                          <v-select :items="distanceOptions" outlined style="width:70px; display: inline-block"
                          @change="addNearConditions"></v-select>
                          以下にする
                        </div>
                        <!-- 近づける生徒の入力フォーム（追加表示のための２つ目以降） -->
                        <div v-for="nearCondition in nearConditions">
                          <v-select :items="studentsName" placeholder="Aさん" outlined style="width:200px; display: inline-block"
                          @change="setNearConditionOption1"></v-select>
                          と
                          <v-select :items="studentsName" placeholder="Bさん" outlined style="width:200px; display: inline-block"
                          @change="setNearConditionOption2"></v-select>
                          の間を
                          <v-select :items="distanceOptions" outlined style="width:70px; display: inline-block"
                          @change="addNearConditions"></v-select>
                          以下にする
                        </div>
                      </v-expansion-panel-content>
                    </v-expansion-panel>
                  </v-expansion-panels>
                </v-col>

                <!-- 離す生徒のエクスパンションパネル -->
                <v-col cols="12" style="background-color: lightgreen">
                  <v-expansion-panels accordion>
                    <v-expansion-panel>
                      <v-expansion-panel-header>生徒同士を離す</v-expansion-panel-header>
                      <v-expansion-panel-content>
                        <!-- 離す生徒の入力フォーム（初期表示のための１つ目） -->
                        <div>
                          <v-select :items="studentsName" placeholder="Aさん" outlined style="width:200px; display: inline-block"
                          @change="setFarConditionOption1"></v-select>
                          と
                          <v-select :items="studentsName" placeholder="Bさん" outlined style="width:200px; display: inline-block"
                          @change="setFarConditionOption2"></v-select>
                          の間を
                          <v-select :items="distanceOptions" outlined style="width:70px; display: inline-block"
                          @change="addFarConditions"></v-select>
                          以上にする
                        </div>
                        <!-- 離す生徒の入力フォーム（追加表示のための２つ目以降） -->
                        <div v-for="farCondition in farConditions">
                          <v-select :items="studentsName" placeholder="Aさん" outlined style="width:200px; display: inline-block"
                          @change="setFarConditionOption1"></v-select>
                          と
                          <v-select :items="studentsName" placeholder="Bさん" outlined style="width:200px; display: inline-block"
                          @change="setFarConditionOption2"></v-select>
                          の間を
                          <v-select :items="distanceOptions" outlined style="width:70px; display: inline-block"
                          @change="addFarConditions"></v-select>
                          以上にする
                        </div>
                      </v-expansion-panel-content>
                    </v-expansion-panel>
                  </v-expansion-panels>
                </v-col>


                <!-- 現在の有効な座席数を表示 -->
                <v-col cols="12" style="background-color: violet">
                  選択された座席数：{{ seatsNum }}
                </v-col>

                <!-- 席替えボタン -->
                <v-col cols="12" style="background-color: khaki">
                  <v-btn elevation="2" outlined @click="changeSeats">席替え！</v-btn>
                </v-col>
              </v-row>
            </v-col>
          </v-row>


          <!-- 以下デバッグ用表示 -->
          <v-row>
            <v-col cols="12" style="background-color: palevioletred">
              <h1 class="text-center">以下デバッグ用</h1>
            </v-col>
          </v-row>

          <v-row>
            <!-- 席替え後の座席テーブル -->
            <v-col cols="6" style="background-color: lightsteelblue">
              <div id="nextSeatArrange">
                <p style="text-align: center">席替え後の座席</p>
                <li v-for="( nextSeats, indexRow ) in nextSeatsTable">
                  <textarea v-for="( seat, indexCol ) in nextSeats" class="seat"
                  :class="getColorByName(nextSeatsTable[indexRow][indexCol])"
                  :key="indexRow.toString() + indexCol.toString()" style="text-align: center;  resize: none; word-break: keep-all"
                  :value="nextSeatsTable[indexRow][indexCol]">
                  </textarea>
                </li>
              </div>
            </v-col>
            <v-col cols="6">
              <v-row>
                <!-- testボタン -->
                <v-col cols="12" style="background-color: darkgray">
                  <v-btn elevation="2" outlined @click="testMethod">テスト！</v-btn>
                </v-col>

                <v-col cols="6" style="background-color: khaki">
                  <p>有効な座席のインデックス配列</p>
                  {{ seatsTableIndex }}
                  <p>有効な座席のインデックス配列の複製</p>
                  {{ dupSeatsTableIndex }}
                </v-col>
                <v-col cols="6" style="background-color: lightsteelblue">
                  <p>最前列の座席のインデックス配列</p>
                  {{ frontSeatsIndex }}
                  <p>最前列の座席のインデックス配列の複製</p>
                  {{ dupFrontSeatsIndex }}
                </v-col>
                <v-col cols="6"  style="background-color: lightsalmon">
                  <div>
                    <p>現在の座席記憶用テーブル</p>
                    <p v-for="seats in seatsTable">{{ seats }}</p>
                  </div>
                </v-col>
                <v-col cols="6"  style="background-color: palegreen">
                  <div>
                    <p>席替え後の座席記憶用テーブル</p>
                    <p v-for="nextSeats in nextSeatsTable">{{ nextSeats }}</p>
                  </div>
                </v-col>
                <v-col cols="6" style="background-color: plum">
                  <p>近づける条件用配列</p>
                  {{ nearConditions }}
                  <p>近づける名前用配列</p>
                  {{ nearStudentsName }}
                  <p>近づける名前用配列の複製</p>
                  {{ dupNearStudentsName }}
                </v-col>
                <v-col cols="6" style="background-color: lightcyan">
                  <p>離す条件用配列</p>
                  {{ farConditions }}
                  <p>離す条件用配列</p>
                  {{ farStudentsName }}
                  <p>離す条件用配列の複製</p>
                  {{ dupFarStudentsName }}
                </v-col>
                <v-col cols="6" style="background-color: palegreen">
                  <p>最前列に固定する生徒</p>
                  {{ frontConditions }}
                </v-col>
                <v-col cols="6" style="background-color: paleturquoise">
                  <p>生徒の名前用配列</p>
                  {{ studentsName }}
                  <p>生徒の名前用配列の複製</p>
                  {{ dupStudentsName }}
                </v-col>
                <v-col cols="6" style="background-color: aliceblue">
                  <p>性別用テーブル</p>
                  <p v-for="seats in genderTable">{{ seats }}</p>
                </v-col>
                <v-col cols="6" style="background-color: #faf2c8">
                  <p>性別用配列</p>
                  {{ genderArray }}
                </v-col>
              </v-row>
            </v-col>
          </v-row>

        </v-container>
      </v-app>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.js"></script>

    <script>
      const app = new Vue({
        el: "#app",
        vuetify: new Vuetify(),
        data: {
          seatsSizeY: 6, // デフォルト値は6
          seatsSizeX: 6, // デフォルト値は6
          seatsTable: [], // 座席テーブル
          seatsNum: 0, // 有効な座席数
          seatsOptionsX: [1,2,3,4,5,6,7,8], // よこの座席数入力フォームの選択肢
          seatsOptionsY: [1,2,3,4,5,6,7,8], // たての座席数入力フォームの選択肢
          distanceOptions: [1,2,3,4,5,6,7,8], // 近づける・離す距離の選択肢
          studentsName: [], // 生徒の名前配列、席替えボタンが2回以上押されたときに元の生徒名を記憶しておくため
          dupStudentsName: [], // 生徒の名前配列の複製、席替えの際に破壊的にデータを取り出していく
          nearConditions: [], // 近づける条件配列
          nearConditionOption1: '', // 近づける生徒1
          nearConditionOption2: '', // 近づける生徒2
          nearStudentsName: [], // 近づける生徒の名前
          dupNearStudentsName: [], // 近づける生徒の名前の複製
          farConditions: [], // 離す条件
          farConditionOption1: '', // 離す生徒1
          farConditionOption2: '', // 離す生徒2
          farStudentsName: [], // 離す生徒の名前
          dupFarStudentsName: [], // 離す生徒の名前の複製
          nearFarStudentsName: [], // 近づける/離す生徒の名前
          dupNearFarStudentsName: [], // 近づける/離す生徒の名前の複製
          frontConditions: [], // 最前列に固定する生徒
          nextSeatsTable: [], // 席替え後の座席テーブル
          tempRow: '', // 2次元配列をリアクティブに更新するために、2次元配列の要素である1次元配列を退避
          seatsTableIndex: [], // 座席テーブル上の有効な座席のインデックス
          dupSeatsTableIndex: [], // 座席テーブル上の有効な座席のインデックスの複製、席替えの際に破壊的にデータを取り出していく
          frontSeatsIndex: [], // 最前列のインデックス
          dupFrontSeatsIndex: [], // 最前列のインデックスの複製、席替えの際に破壊的にデータを取り出していく
          calcNum: 0, // 計算回数、無限ループに入ったときに抜け出す用
          restartFlag: false, // 条件を満たしていないとき、changeSeats()の最初からリスタートする制御用フラグ
          genderTable: [], // 生徒の性別テーブル
          genderArray: [], // 生徒の性別配列、テーブルを展開したもの、studentsName[]と順番が対応
          isAllDifferent: true, // 前回の座席と異なる配置にするかどうかの制御フラグ
          isFixGender: true, // 性別を固定するかどうかの制御フラグ
        },
        methods: {
          testMethod() { // デバッグ用。最後に消す。
            console.log('---------')
          },
          /*getColorByIndex(col, row) { // 座席の種類に応じた色を返す
            if(this.genderTable[row][col] === '') {
              return 'off-seats'
            }else if(this.genderTable[row][col] === 'male'){
              return 'male-seats'
            }else if(this.genderTable[row][col] === 'female'){
              return 'female-seats'
            }else return 'on-seats'
          },*/
          getColorByName(studentName) { // 座席の種類に応じた色を返す
            let genderIndex = this.studentsName.indexOf(studentName); // 生徒名に対応する性別を取得
            let gender
            if(genderIndex === -1){ //
              gender = ''
            }else{
              gender = this.genderArray[genderIndex];
            }
            if(gender === '') {
              return 'off-seats'
            }else if(gender === 'male'){
              return 'male-seats'
            }else if(gender === 'female'){
              return 'female-seats'
            }else return 'on-seats'
          },
          toggleGender(col, row) {
            if(this.genderTable[row][col] === 'male'){
              this.genderTable[row].splice(col, 1, 'female')
            }else if(this.genderTable[row][col] === 'female'){
              this.genderTable[row].splice(col, 1, 'male')
            }
          },
          writeStudentName(indexCol, indexRow, name) { // 引数で受け取った座席の有効・無効を切り替える
            this.seatsTable[indexRow].splice(indexCol, 1, name)
            if(this.genderTable[indexRow][indexCol] === ''){
              this.genderTable[indexRow].splice(indexCol, 1, 'male')
            }
          },
          makeSeatsTable() { // seatsTableを作成
            this.seatsTable = []
            for(let i = 0; i < this.seatsSizeY; i++) {
              this.seatsTable.push( Array(this.seatsSizeX).fill('') ) // すべての席に名前が未入力な状態でテーブルを作成
            }
            this.countSeats();
          },
          countSeats() { // 有効な座席数をカウント
            this.seatsNum = 0;
            this.seatsTable.forEach(seatsRow => {
              seatsRow.forEach(seat => {
                if (seat !== '') this.seatsNum += 1
              })
            })
          },
          setNearConditionOption1(nearConditionOption1) { // 近づける条件で指定する生徒1を登録
            this.nearConditionOption1 = nearConditionOption1;
          },
          setNearConditionOption2(nearConditionOption2) {　// 近づける条件で指定する生徒2を登録
            this.nearConditionOption2 = nearConditionOption2;
          },
          addNearConditions(distance) { // 生徒1と生徒2を近づける条件を登録
            this.nearConditions.push( [this.nearConditionOption1, this.nearConditionOption2, distance] );
          },
          setFarConditionOption1(farConditionOption1) { // 離す条件で指定する生徒1を登録
            this.farConditionOption1 = farConditionOption1;
          },
          setFarConditionOption2(farConditionOption2) { // 離す条件で指定する生徒2を登録
            this.farConditionOption2 = farConditionOption2;
          },
          addFarConditions(distance) { // 生徒1と生徒2を離す条件を登録
            this.farConditions.push( [this.farConditionOption1, this.farConditionOption2, distance] )
          },
          addFrontConditions(studentName) { // 最前列に固定する条件を要録
            this.frontConditions.push(studentName);
          },
          makeNextSeatsTable() { // nextSeatsTableを作成
            this.nextSeatsTable = []
            for(let i = 0; i < this.seatsSizeY; i++) {
              this.nextSeatsTable.push( Array(this.seatsSizeX).fill('') ) // すべての席に名前が未入力な状態でテーブルを作成
            }
          },
          resetNextSeatsTable() { // nextSeatsTableを空白で初期化
            for(let i = 0; i < this.seatsSizeY; i++) {
              this.nextSeatsTable.splice(i, 1, Array(this.seatsSizeX).fill(''));
            }
          },
          changeSeats() { // メイン処理
            let loopNum = 0; // changeSeats()の処理を指定された回数繰り返す際に制御する変数
            do {
              loopNum += 1;
              console.log(`----${loopNum}回目のループを開始します----`);
              this.restartFlag = false;
              this.calcNum = 0 // エラー用計算量を初期化
              this.resetNextSeatsTable(); // 席替え後座席テーブルを初期化する
              this.resetFrontSeatsIndex(); // 最前列インデックス配列を空にする
              this.makeFrontSeatsIndex(); // 最前列インデックスを作成
              this.dupSeatsTableIndex = this.seatsTableIndex.slice(0); // 有効な座席のインデックスを複製、席替えの際にこの配列から破壊的にデータを取り出していく
              this.dupFrontSeatsIndex = this.frontSeatsIndex.slice(0); // 最前列の座席のインデックスを複製、席替えの際にこの配列から破壊的にデータを取り出していく
              this.dupStudentsName = this.studentsName.slice(0); // 生徒名を複製、席替えの際にこの配列から破壊的にデータを取り出していく
              this.dupNearStudentsName = this.nearStudentsName.slice(0); // 近づける生徒名を複製、席替えの際にこの配列から破壊的にデータを取り出していく
              this.dupFarStudentsName = this.farStudentsName.slice(0); // 離す生徒名を複製、席替えの際にこの配列から破壊的にデータを取り出していく
              this.dupNearFarStudentsName = this.nearStudentsName.concat(this.farStudentsName); // 近づける生徒名と離す生徒名を結合、席替えの際にこの配列から破壊的にデータを取り出していく
              this.dupNearFarStudentsName = Array.from(new Set(this.dupNearFarStudentsName)) // 重複している名前を削除
              this.changeFrontSeats(); // 最前列に固定する生徒を席替え
              //this.changeNearSeats(); // 近づける生徒を席替え
              //this.changeFarSeats(); // 離す生徒を席替え
              this.changeNearFarSeats(); // 近づける/離す生徒を席替え
              this.shuffleSeats(); // 条件のない生徒を席替え
              console.log(`----${loopNum}回目のループ終了----`);
            } while(this.restartFlag && loopNum <= 100)
            console.log(`====終了====`);
            if(loopNum > 100){
              window.alert('条件を満たす席替えを実現できませんでした。\n何回か試してもエラーが出るようでしたら、条件を変更してください。');
            }
          },
          pushSeatsTableIndex(indexCol, indexRow) { // 座席テーブルの有効な座席のインデックスをプッシュ
            this.seatsTableIndex.push([indexCol, indexRow]);
          },
          shuffleSeats() { // 条件のない生徒を席替え
            this.shuffle(this.dupSeatsTableIndex); // インデックスをシャッフル
            this.dupStudentsName.forEach(dupStudentName => { // 生徒を一人取り出す
              let topIndex = this.dupSeatsTableIndex.shift(); // シャッフルしたインデックスを格納した配列の先頭を取り出す
              while( this.isFixGender && !this.checkGender(dupStudentName, topIndex) ){ // 征伐の条件を満たさない間、繰り返す
                if(this.calcNum > this.seatsNum){
                  // window.alert('条件を満たす席替えを実現できませんでした。\n何回か試してもエラーが出るようでしたら、条件を変更してください。');
                  // throw '計算量が100を超えました'
                  this.restartFlag = true;
                  break;
                }
                this.dupSeatsTableIndex.push(topIndex); // 取り出したインデックスを配列の最後にプッシュして
                topIndex = this.dupSeatsTableIndex.shift(); // 配列先頭のインデックスを再度取り出す
                this.calcNum += 1;
              }
              this.nextSeatsTable[topIndex[1]].splice(topIndex[0], 1, dupStudentName); // 取り出したインデックスの位置に生徒名を保存
            })
          },
          shuffle(array) { // 配列をランダムにシャッフル
            for (let i = array.length - 1; i >= 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              const tempValue = array[i];
              array.splice(i, 1, array[j]);
              array.splice(j, 1, tempValue);
            }
          },
          makeFrontSeatsIndex() {
            this.seatsTableIndex.forEach(indexArray => {
              if(indexArray[1] === 0) { // 最前列なら
                this.frontSeatsIndex.push(indexArray); // 最前列インデックス配列にインデックスをプッシュ
              }
            })
          },
          changeFrontSeats() { // 最前列に固定する生徒を席替え
            this.shuffle(this.dupFrontSeatsIndex);
            this.frontConditions.forEach(frontStudentName => {
              let topIndex = this.dupFrontSeatsIndex.shift(); // シャッフルしたインデックスを格納した配列の先頭を取り出す
              /* ----近づける/離す処理---- */
              while( !this.checkNear(frontStudentName, topIndex) || !this.checkFar(frontStudentName, topIndex) || ( this.isFixGender && !this.checkGender(frontStudentName, topIndex)) ){ // どちらかの条件を満たさない間、繰り返す
                if(this.calcNum > this.seatsNum){
                  // window.alert('条件を満たす席替えを実現できませんでした。\n何回か試してもエラーが出るようでしたら、条件を変更してください。');
                  // throw '計算量が100を超えました'
                  this.restartFlag = true;
                  break;
                }
                this.dupFrontSeatsIndex.push(topIndex); // 取り出したインデックスを配列の最後にプッシュして
                topIndex = this.dupFrontSeatsIndex.shift(); // 配列先頭のインデックスを再度取り出す
                this.calcNum += 1;
              }
              /* ----ここまで---- */
              this.nextSeatsTable[topIndex[1]].splice(topIndex[0], 1, frontStudentName); // 取り出したインデックスの位置に生徒名を保存

              let deleteIndex = this.dupSeatsTableIndex.indexOf(topIndex); // changeFrontSeats()で配置した生徒は、shuffleSeats()で配置する必要がないため
              this.dupSeatsTableIndex.splice(deleteIndex, 1); // dupSeatsTableIndexから削除する

              let deleteStudentNameIndex = this.dupStudentsName.indexOf(frontStudentName); // changeFrontSeats()で配置した生徒は、shuffleSeats()で配置する必要がないため
              this.dupStudentsName.splice(deleteStudentNameIndex, 1); // dupStudentsNameから削除する

              let deleteNearStudentNameIndex = this.dupNearStudentsName.indexOf(frontStudentName); // changeFrontSeats()で配置した生徒は、changeNearSeats()で配置する必要がないため
              if(deleteNearStudentNameIndex != -1){ // dupNearStudentsNameにあれば削除する
                this.dupNearStudentsName.splice(deleteNearStudentNameIndex, 1); // dupNearStudentsNameから削除する
              }

              let deleteFarStudentNameIndex = this.dupFarStudentsName.indexOf(frontStudentName); // changeFrontSeats()で配置した生徒は、changeFarSeats()で配置する必要がないため
              if(deleteFarStudentNameIndex != -1){ // dupFarStudentsNameにあれば削除する
                this.dupFarStudentsName.splice(deleteFarStudentNameIndex, 1); // dupFarStudentsNameから削除する
              }

              let deleteNearFarStudentNameIndex = this.dupNearFarStudentsName.indexOf(frontStudentName); // changeNearFrontSeats()で配置した生徒は、changeFarSeats()で配置する必要がないため
              if(deleteNearFarStudentNameIndex != -1){ // dupNearFarStudentsNameにあれば削除する
                this.dupNearFarStudentsName.splice(deleteNearFarStudentNameIndex, 1); // dupNearFarStudentsNameから削除する
              }
              // console.log(`${frontStudentName}を配置した`)
            })
          },
          /*
          changeNearSeats() { // 近づける生徒を席替え
            this.shuffle(this.dupSeatsTableIndex);
            this.dupNearStudentsName.forEach(dupNearStudentName => {
              let topIndex = this.dupSeatsTableIndex.shift(); // シャッフルしたインデックスを格納した配列の先頭を取り出す
              //console.log(`${dupNearStudentName} を ${topIndex} に入れるのは ${this.checkNear(dupNearStudentName, topIndex)} (${this.calcNum}回目の計算)`);
              // ----近づける処理----
              console.log(`dupNearStudentsName = ${this.dupNearStudentsName}`)
              while( !this.checkNear(dupNearStudentName, topIndex) ){ // 条件を満たさない間、繰り返す
                if(this.calcNum > 100){
                  window.alert('条件を満たす席替えを実現できませんでした。\n何回か試してもエラーが出るようでしたら、条件を変更してください。');
                  throw '計算量が100を超えました'
                }
                this.dupSeatsTableIndex.push(topIndex); // 取り出したインデックスを配列の最後にプッシュして
                topIndex = this.dupSeatsTableIndex.shift(); // 配列先頭のインデックスを再度取り出す
                // console.log(`${dupNearStudentName} を ${topIndex} に入れるのは ${this.checkNear(dupNearStudentName, topIndex)} (while内${this.calcNum}回目の計算)`);
                this.calcNum += 1;
              }
              // ----ここまで----
              this.nextSeatsTable[topIndex[1]].splice(topIndex[0], 1, dupNearStudentName); // 取り出したインデックスの位置に生徒名を保存

              let deleteStudentNameIndex = this.dupStudentsName.indexOf(dupNearStudentName); // changeNearSeats()で配置した生徒は、shuffleSeats()で配置する必要がないため
              this.dupStudentsName.splice(deleteStudentNameIndex, 1); // dupStudentsNameから削除する
              console.log(`${dupNearStudentName}を配置した`)

              let deleteFarStudentNameIndex = this.dupFarStudentsName.indexOf(dupNearStudentName); // changeNearSeats()で配置した生徒は、changeFarSeats()で配置する必要がないため
              if(deleteFarStudentNameIndex != -1){ // dupFarStudentsNameにあれば削除する
                this.dupFarStudentsName.splice(deleteFarStudentNameIndex, 1); // dupFarStudentsNameから削除する
              }
            })
          },
          */
          /*
          changeFarSeats() { // 離す生徒を席替え
            this.shuffle(this.dupSeatsTableIndex);
            this.dupFarStudentsName.forEach(dupFarStudentName => {
              let topIndex = this.dupSeatsTableIndex.shift(); // シャッフルしたインデックスを格納した配列の先頭を取り出す
              //console.log(`${dupNearStudentName} を ${topIndex} に入れるのは ${this.checkNear(dupNearStudentName, topIndex)} (${this.calcNum}回目の計算)`);
              // ----離す処理----
              console.log(`dupFarStudentsName = ${this.dupFarStudentsName}`)
              while( !this.checkFar(dupFarStudentName, topIndex) ){ // 条件を満たさない間、繰り返す
                if(this.calcNum > 100){
                  window.alert('条件を満たす席替えを実現できませんでした。\n何回か試してもエラーが出るようでしたら、条件を変更してください。');
                  throw '計算量が100を超えました'
                }
                this.dupSeatsTableIndex.push(topIndex); // 取り出したインデックスを配列の最後にプッシュして
                topIndex = this.dupSeatsTableIndex.shift(); // 配列先頭のインデックスを再度取り出す
                console.log(`${dupFarStudentName} を ${topIndex} に入れるのは ${this.checkFar(dupFarStudentName, topIndex)} (while内${this.calcNum}回目の計算)`);
                this.calcNum += 1;
              }
              // ----ここまで----
              this.nextSeatsTable[topIndex[1]].splice(topIndex[0], 1, dupFarStudentName); // 取り出したインデックスの位置に生徒名を保存

              let deleteStudentNameIndex = this.dupStudentsName.indexOf(dupFarStudentName); // changeNearSeats()で配置した生徒は、shuffleSeats()で配置する必要がないため
              this.dupStudentsName.splice(deleteStudentNameIndex, 1); // dupStudentsNameから削除する
              console.log(`${dupFarStudentName}を配置した`)
            })
          },
          */
          changeNearFarSeats() { // 近づける/離す生徒を席替え
            this.shuffle(this.dupSeatsTableIndex);
            this.dupNearFarStudentsName.forEach(dupNearFarStudentName => {
              let topIndex = this.dupSeatsTableIndex.shift(); // シャッフルしたインデックスを格納した配列の先頭を取り出す
              //console.log(`${dupNearStudentName} を ${topIndex} に入れるのは ${this.checkNear(dupNearStudentName, topIndex)} (${this.calcNum}回目の計算)`);
              /* ----近づける/離す処理---- */
              while( !this.checkNear(dupNearFarStudentName, topIndex) || !this.checkFar(dupNearFarStudentName, topIndex) || (this.isFixGender && !this.checkGender(dupNearFarStudentName, topIndex)) ){ // どちらかの条件を満たさない間、繰り返す
                if(this.calcNum > this.seatsNum){
                  //window.alert('条件を満たす席替えを実現できませんでした。\n何回か試してもエラーが出るようでしたら、条件を変更してください。');
                  this.restartFlag = true;
                  //window.alert('restartFlagをtrueにしました。');
                  break;
                }
                this.dupSeatsTableIndex.push(topIndex); // 取り出したインデックスを配列の最後にプッシュして
                topIndex = this.dupSeatsTableIndex.shift(); // 配列先頭のインデックスを再度取り出す
                //console.log(`${dupNearFarStudentName} を ${topIndex} に入れるとき、checkNearは ${this.checkNear(dupNearFarStudentName, topIndex)}、checkFarは ${this.checkFar(dupNearFarStudentName, topIndex)} (while内${this.calcNum}回目の計算)`);
                this.calcNum += 1;
              }
              /* ----ここまで---- */
              this.nextSeatsTable[topIndex[1]].splice(topIndex[0], 1, dupNearFarStudentName); // 取り出したインデックスの位置に生徒名を保存

              let deleteStudentNameIndex = this.dupStudentsName.indexOf(dupNearFarStudentName); // changeNearSeats()で配置した生徒は、shuffleSeats()で配置する必要がないため
              this.dupStudentsName.splice(deleteStudentNameIndex, 1); // dupStudentsNameから削除する
              // console.log(`${dupNearFarStudentName}を配置した`)
            })
          },
          resetFrontSeatsIndex() { // 最前列インデックス配列を空にする
            this.frontSeatsIndex.splice(0);
          },
          min_distance(p1, p2) { // 2点の距離のminを返す。p1, p2は座標、たとえばp1=[1,2]
            let x_abs = Math.abs( p1[0] - p2[0] );
            let y_abs = Math.abs( p1[1] - p2[1] );
            return Math.min(x_abs, y_abs);
          },
          max_distance(p1, p2) { // 2点の距離のmaxを返す。p1, p2は座標、たとえばp1=[1,2]
            let x_abs = Math.abs( p1[0] - p2[0] );
            let y_abs = Math.abs( p1[1] - p2[1] );
            return Math.max(x_abs, y_abs);
          },
          checkNear(studentName, p) { // 引数の生徒を座標pに配置しても、近づける条件を満たすならtrue、満たさないならfalseを返す
            let return_value = true
            this.nearConditions.forEach(nearConditionArray => {
              if( nearConditionArray.includes(studentName) ){ // もし引数の生徒が、近づける条件にいれば
                /* ----近づけたい生徒の名前を取得---- */
                let nearStudentName
                if( nearConditionArray.indexOf(studentName) == 0 ){
                  nearStudentName = nearConditionArray[1]; // 引数の生徒と近づけたい生徒
                }else if( nearConditionArray.indexOf(studentName) == 1 ){
                  nearStudentName = nearConditionArray[0]; // 引数の生徒と近づけたい生徒
                }
                /* ----ここまで---- */
                let distance = nearConditionArray[2]; // 距離
                let nearStudentPosition = this.getPositionFromNextSeatsTable(nearStudentName); // すでに配置されていればその座標、まだ配置されてなければfalse
                // console.log(`${nearStudentName} の場所は ${nearStudentPosition}`);
                // console.log(`距離は${this.max_distance(p, nearStudentPosition)}`);
                if( this.max_distance(p, nearStudentPosition) > distance ){ // 距離のmaxが条件distanceより上なら返り値をfalseに更新
                  return_value = false;
                }
              }
            })
            return return_value;
          },
          checkFar(studentName, p) { // 引数の生徒を座標pに配置しても、離す条件を満たすならtrue、満たさないならfalseを返す
            let return_value = true
            this.farConditions.forEach(farConditionArray => {
              if( farConditionArray.includes(studentName) ){ // もし引数の生徒が、離す条件にいれば
                /* ----離す生徒の名前を取得---- */
                let farStudentName
                if( farConditionArray.indexOf(studentName) == 0 ){
                  farStudentName = farConditionArray[1]; // 引数の生徒と離す生徒
                }else if( farConditionArray.indexOf(studentName) == 1 ){
                  farStudentName = farConditionArray[0]; // 引数の生徒と離す生徒
                }
                /* ----ここまで---- */
                let distance = farConditionArray[2]; // 距離
                let farStudentPosition = this.getPositionFromNextSeatsTable(farStudentName); // すでに配置されていればその座標、まだ配置されてなければfalse
                // console.log(`${nearStudentName} の場所は ${nearStudentPosition}`);
                // console.log(`距離は${this.max_distance(p, nearStudentPosition)}`);
                if( this.max_distance(p, farStudentPosition) < distance ){ // 距離のminが条件distanceより下なら返り値をfalseに更新
                  return_value = false;
                }
              }
            })
            return return_value;
          },
          checkGender(studentName, p) { // 引数の生徒を座標pに配置しても、性別の条件を満たすならtrue、満たさないならfalseを返す
            let genderIndex = this.studentsName.indexOf(studentName);
            let currentGender = this.genderArray[genderIndex]; // 引数の生徒の性別
            let nextGender = this.genderTable[p[1]][p[0]]; // 性別テーブルに記憶している性別
            if(currentGender === nextGender){
              return true
            }else{
              return false
            }
          },
          getPositionFromNextSeatsTable(studentName) { // 引数の生徒が席替え後座席テーブルにすでにいればその座標を、いなければfalseを返す
            let nextSeatsRowNum = 0; // 行インデックス、y座標
            let return_value = false; // 返す値の初期値をfalse
            this.nextSeatsTable.forEach(nextSeatsRow => {
              if( nextSeatsRow.includes(studentName) ){
                let nextSeatsColNum = nextSeatsRow.indexOf(studentName);
                return_value = [nextSeatsColNum, nextSeatsRowNum]; // 返す値を座標で更新
              }
              nextSeatsRowNum += 1;
            })
            return return_value;
          },
          makeGenderTable() { // genderTableを作成
            this.genderTable = []
            for(let i = 0; i < this.seatsSizeY; i++) {
              this.genderTable.push( Array(this.seatsSizeX).fill('') ) // すべての席に性別が未入力な状態でテーブルを作成
            }
          },
        },
        mounted() {
          this.makeSeatsTable() // 最初にseatsTableを作成
          this.makeNextSeatsTable() // 席替え後用のnextSeatsTableを空白で作成
          this.makeGenderTable() // genderTableを作成
        },
        watch: {
          seatsTable: {
            handler: function(){
              this.studentsName = Array.prototype.concat.apply([], this.seatsTable); //seatsTableを展開
              this.studentsName = this.studentsName.filter(function(studentName) { //空白を削除
                return studentName !== '';
              })
            },
            deep: true
          },
          nearConditions: {
            handler: function(){
              this.nearStudentsName.splice(-this.nearStudentsName.length); // 配列を初期化
              this.nearConditions.forEach( nearCondition => {
                this.nearStudentsName.push(nearCondition[0], nearCondition[1]);
              })
              this.nearStudentsName = Array.from(new Set(this.nearStudentsName)) // 重複している名前を削除
            }
          },
          farConditions: {
            handler: function(){
              this.farStudentsName.splice(-this.farStudentsName.length); // 配列を初期化
              this.farConditions.forEach( farCondition => {
                this.farStudentsName.push(farCondition[0], farCondition[1]);
              })
              this.farStudentsName = Array.from(new Set(this.farStudentsName)) // 重複している名前を削除
            }
          },
          genderTable: {
            handler: function(){
              this.genderArray = Array.prototype.concat.apply([], this.genderTable); //genderTableを展開
              this.genderArray = this.genderArray.filter(function(genderArray) { //空白を削除
                return genderArray !== '';
              })
            },
            deep: true
          },
        }
      });
    </script>
  </body>
</html>
