<!DOCTYPE html>
<html>
  <head>
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/@mdi/font@4.x/css/materialdesignicons.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.min.css" rel="stylesheet">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
    <style>
      li {
        text-align: center;
        list-style: none;
        margin-bottom: -7px;
      }
      .background-color {
        /* degital water */
        background: #EDE574;  /* fallback for old browsers */
        background: -webkit-linear-gradient(to right, #E1F5C4, #EDE574);  /* Chrome 10-25, Safari 5.1-6 */
        background: linear-gradient(to right, #E1F5C4, #EDE574); /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */
      }
      .right {
        float: right;
      }
      /* サイドバー内のセレクトボックス */
      .v-text-field.v-text-field--enclosed {
        margin-right: 10px;
      }
      .expansion-panels {
        margin-bottom: 10px;
      }
      .change-seats-button {
        margin-top: 10px;
      }
      .on-seats {
        background: mediumaquamarine;
      }
      .male-seats {
        background: #add8e6;
      }
      .female-seats {
        background: #d9c3d9;
      }
      .off-seats {
        background: gainsboro;
      }
      .seat{
        height: 80px;
        width: 80px;
        display: inline-block;
        border: 3px solid #F36304 ;
        box-sizing: border-box;
        text-align: center;
      }
      .margin-right {
        margin-right: 10px;
      }
      .minus-margin-right {
        margin-right: -4px;
      }
      .margin-bottom {
        padding-bottom: 10px;
      }
      .margin-bottom-35 {
        margin:35px 0;
      }
      .margin-top-35 {
        margin-top: 35px;
        margin-bottom: -50px;
      }
      .minus-margin-bottom {
        vertical-align: bottom;
        margin-bottom: -7px;
      }
      .center {
        text-align: center;
      }
      .inline-block {
        display: inline-block;
      }
      .square {
        display: inline-block;
        margin: 0 auto;
        height: 80px;
        width: 80px;
      }
      /* vuetifyのスタイルをオーバーライド、選択されてdisabledになった文字のカラーをblackにする */
      .theme--light.v-select .v-select__selection--disabled{
        color: black;
      }
      /* vuetifyのスタイルをオーバーライド、サイドメニューの開閉速度を設定 */
      .v-navigation-drawer {
        transition-duration: 0.5s;
      }
      .v-navigation-drawer {
        box-shadow: -4px 0 4px #a9a9a9;
      }
      .box-shadow {
        box-shadow: 0 0 10px 6px #a9a9a9;
      }
      [v-cloak] {
        display: none;
      }
      /* sortableJSで選択された座席 */
      .highlighted {
        background-color: #9AB6F1;
      }
      .sortable-item:hover {
        cursor: grab;
      }
      .sortable-item:active .sortable-ghost, .sortable-chosen .sortable-drag {
        cursor: grabbing;
        cursor: -moz-grabbing;
        cursor: -webkit-grabbing;
      }
      .transition-item-move {
        transition: transform 1s;
      }
      .transition-item-enter-active, .transition-item-leave-active {
        transition: all 0s;
      }
    </style>
  </head>
  <body>
    <div id="app" v-cloak>
      <v-app>
        <v-container fluid class="background-color">
          <v-row>
            <!-- タイトル -->
            <v-col cols="6">
              <h1 class="text-center">席替えメーカー</h1>
            </v-col>
            <v-col cols="6">
              <v-app-bar-nav-icon @click.stop="drawer = !drawer" class="right margin-top-35"></v-app-bar-nav-icon>
            </v-col>
          </v-row>

          <v-row>
            <v-col cols="6">
              <!-- サイドバー -->
              <template>
                <v-navigation-drawer v-model="drawer" absolute right width="50%" color="#c0c0c0">
                  <v-list nav dense>
                    <v-list-item-group>
                      <v-list-item class="right">
                        <v-app-bar-nav-icon @click.stop="drawer = !drawer"></v-app-bar-nav-icon>
                      </v-list-item>
                      <h1 class="margin-bottom-35">条件</h1>
                      <!-- 座席数のセレクトボックス -->
                      <v-select :items="seatsOptionsX" label="全体の横の座席数" outlined　v-model.number="seatsSizeX" style="width:125px" class="inline-block"></v-select>
                      <v-select :items="seatsOptionsY" label="全体の縦の座席数" outlined　v-model.number="seatsSizeY" style="width:125px" class="inline-block"></v-select>
                      <v-select :items="groupSizeOptionsX" label="班の横の座席数" outlined　v-model.number="groupSizeX" style="width:110px" class="inline-block"></v-select>
                      <v-select :items="groupSizeOptionsY" label="班の縦の座席数" outlined　v-model.number="groupSizeY" style="width:110px" class="inline-block"></v-select>

                      <!-- 前後で指定するエクスパンションパネル -->
                      <v-expansion-panels accordion class="expansion-panels">
                        <v-expansion-panel>
                          <v-expansion-panel-header>前後で指定する</v-expansion-panel-header>
                          <v-expansion-panel-content>
                            <v-expansion-panels accordion multiple>
                              <!-- 最前列のエクスパンションパネル -->
                              <v-expansion-panel>
                                <v-expansion-panel-header>最前列</v-expansion-panel-header>
                                <v-expansion-panel-content>
                                  <span v-for="(frontCondition, frontIndex) in frontConditions">
                                    <v-select :items="rowConditionsStudentsName" placeholder="Aさん" outlined style="width:190px; display: inline-block"
                                    v-model="frontConditions[frontIndex]" @change.once="createNewFrontConditions"></v-select>
                                  </span>
                                </v-expansion-panel-content>
                              </v-expansion-panel>
                              <!-- 前2列のエクスパンションパネル -->
                              <v-expansion-panel>
                                <v-expansion-panel-header>前2列</v-expansion-panel-header>
                                <v-expansion-panel-content>
                                  <span v-for="(frontTwoRowsCondition, frontTwoRowsIndex) in frontTwoRowsConditions">
                                    <v-select :items="rowConditionsStudentsName" placeholder="Aさん" outlined style="width:190px; display: inline-block"
                                    v-model="frontTwoRowsConditions[frontTwoRowsIndex]" @change.once="createNewFrontTwoRowsConditions"></v-select>
                                  </span>
                                </v-expansion-panel-content>
                              </v-expansion-panel>
                              <!-- 後ろ2列のエクスパンションパネル -->
                              <v-expansion-panel>
                                <v-expansion-panel-header>後ろ2列</v-expansion-panel-header>
                                <v-expansion-panel-content>
                                  <span v-for="(backTwoRowsCondition, backTwoRowsIndex) in backTwoRowsConditions">
                                    <v-select :items="rowConditionsStudentsName" placeholder="Aさん" outlined style="width:190px; display: inline-block"
                                    v-model="backTwoRowsConditions[backTwoRowsIndex]" @change.once="createNewBackTwoRowsConditions"></v-select>
                                  </span>
                                </v-expansion-panel-content>
                              </v-expansion-panel>
                              <!-- 最後列のエクスパンションパネル -->
                              <v-expansion-panel>
                                <v-expansion-panel-header>最後列</v-expansion-panel-header>
                                <v-expansion-panel-content>
                                  <span v-for="(backCondition, backIndex) in backConditions">
                                    <v-select :items="rowConditionsStudentsName" placeholder="Aさん" outlined style="width:190px; display: inline-block"
                                    v-model="backConditions[backIndex]" @change.once="createNewBackConditions"></v-select>
                                  </span>
                                </v-expansion-panel-content>
                              </v-expansion-panel>
                            </v-expansion-panels>
                          </v-expansion-panel-content>
                        </v-expansion-panel>
                      </v-expansion-panels>

                      <!-- 特定の座席に固定するエクスパンションパネル -->
                      <v-expansion-panels accordion class="expansion-panels">
                        <v-expansion-panel>
                          <v-expansion-panel-header>特定の座席に固定する</v-expansion-panel-header>
                          <v-expansion-panel-content>
                            <div v-for="(fixCondition, fixIndex) in fixConditions">
                              <v-select :items="studentsName" placeholder="Aさん" outlined style="width:190px; display: inline-block"
                              v-model="fixConditions[fixIndex][0]"></v-select>
                              を、前から
                              <v-select :items="limitedSeatsOptionsY" outlined style="width:70px; display: inline-block"
                              v-model="fixConditions[fixIndex][1]"></v-select>
                              列目、左から
                              <v-select :items="limitedSeatsOptionsX" outlined style="width:70px; display: inline-block"
                              v-model="fixConditions[fixIndex][2]" @change.once="createNewFixConditions"></v-select>
                              列目に固定する
                            </div>
                          </v-expansion-panel-content>
                        </v-expansion-panel>
                      </v-expansion-panels>

                      <!-- 近づける生徒のエクスパンションパネル -->
                      <v-expansion-panels accordion class="expansion-panels">
                        <v-expansion-panel>
                          <v-expansion-panel-header>生徒同士を近づける</v-expansion-panel-header>
                          <v-expansion-panel-content>
                            <div v-for="(nearCondition, nearIndex) in nearConditions">
                              <v-select :items="studentsName" placeholder="Aさん" outlined style="width:190px; display: inline-block"
                              v-model="nearConditions[nearIndex][0]"></v-select>
                              と
                              <v-select :items="studentsName" placeholder="Bさん" outlined style="width:190px; display: inline-block"
                              v-model="nearConditions[nearIndex][1]"></v-select>
                              の間を
                              <v-select :items="distanceOptions" outlined style="width:70px; display: inline-block"
                              v-model="nearConditions[nearIndex][2]" @change.once="createNewNearConditions"></v-select>
                              席以下にする
                            </div>
                          </v-expansion-panel-content>
                        </v-expansion-panel>
                      </v-expansion-panels>

                      <!-- 離す生徒のエクスパンションパネル -->
                      <v-expansion-panels accordion class="expansion-panels">
                        <v-expansion-panel>
                          <v-expansion-panel-header>生徒同士を離す</v-expansion-panel-header>
                          <v-expansion-panel-content>
                            <div v-for="(farCondition, farIndex) in farConditions">
                              <v-select :items="studentsName" placeholder="Aさん" outlined style="width:190px; display: inline-block"
                              v-model="farConditions[farIndex][0]"></v-select>
                              と
                              <v-select :items="studentsName" placeholder="Bさん" outlined style="width:190px; display: inline-block"
                              v-model="farConditions[farIndex][1]"></v-select>
                              の間を
                              <v-select :items="distanceOptions" outlined style="width:70px; display: inline-block"
                              v-model="farConditions[farIndex][2]" @change.once="createNewFarConditions"></v-select>
                              席以上空ける
                            </div>
                          </v-expansion-panel-content>
                        </v-expansion-panel>
                      </v-expansion-panels>

                      <!-- チェックボックス -->
                      <v-checkbox label="現在の座席と異なる座席にする" v-model="isAllDifferent" hide-details></v-checkbox>
                      <v-checkbox label="男女の座席を固定する" v-model="isFixGender" hide-details></v-checkbox>

                      <!-- 席替えボタン -->
                      <v-btn elevation="2" outlined @click="beforeChangeSeats(); delayChangeSeats(); drawer = false" class="change-seats-button">席替え！</v-btn>
                    </v-list-item-group>
                  </v-list>
                </v-navigation-drawer>
                <!-- サイドバーここまで -->
              </template>
            </v-col>
          </v-row>

          <v-row>
            <!-- 座席テーブル -->
            <v-col cols="6">
              <v-card outlined color="#F36304" class="box-shadow">
                <v-card-title class="justify-center white--text text-h4">現在の座席</v-card-title>
                <v-card-subtitle class="justify-center text-center white--text">現在の座席に名前を入力してください<br>クリックで性別を変更できます</v-card-subtitle>
                <div>
                  <li v-for="( seats, indexRow ) in seatsTable">
                    <span v-for="( seat, indexCol ) in seats" class="minus-margin-right">
                      <textarea
                      :class="['seat', getColorByName(seatsTable[indexRow][indexCol]), ]"
                      @input="writeStudentName( indexCol, indexRow, $event.target.value ); countSeats();"
                      :key="indexRow.toString() + indexCol.toString()"
                      style="text-align: center;  resize: none; word-break: keep-all"
                      :value="seatsTable[indexRow][indexCol]"
                      @click="toggleGender(indexCol,indexRow)">
                    </textarea>
                    <span :class="{'margin-right': (indexCol+1)%groupSizeX==0}"></span>
                  </span>
                  <div :class="{'margin-bottom': (indexRow+1)%groupSizeY==0}"></div>
                  </li>
                </div>
              </v-card>
              <v-btn elevation="2" outlined @click="beforeChangeSeats(); delayChangeSeats();">席替え！</v-btn>
            </v-col>

            <!-- 席替え後の座席テーブル -->
            <v-col cols="6">
              <v-card outlined color="#F36304" class="box-shadow">
                <v-card-title class="justify-center white--text text-h4">席替え後の座席</v-card-title>
                <v-card-subtitle class="justify-center text-center"><br><br></v-card-subtitle>
                <template v-if="isRenderNextSeatsTable">
                  <div class="center">
                    <transition-group name="transition-item" type="transition">
                      <template v-for="( nextSeats, nextIndexRow ) in nextSeatsTable" >
                        <template v-for="( nextSeat, nextIndexCol ) in nextSeats">
                          <span :id="'nextSeatsRow' + nextIndexRow + nextIndexCol" class="sortable-item transition-item square minus-margin-bottom" :key="uniqueKey(nextSeat, nextIndexRow, nextIndexCol)">
                            <textarea class="sortable-item"
                            :class="['seat', getColorByName(nextSeatsTable[nextIndexRow][nextIndexCol])]"
                            style="text-align: center;  resize: none; word-break: keep-all"
                            :value="nextSeatsTable[nextIndexRow][nextIndexCol]"
                            @input="testMethod2(nextIndexCol, nextIndexRow, $event.target.value )">
                            </textarea>
                          </span>
                          <span :class="{'margin-right': (nextIndexCol+1)%groupSizeX==0}" :key="'nextSeatsSpan' + (nextIndexRow*seatsSizeX+nextIndexCol)"></span>
                        </template>
                        <div :class="{'margin-bottom': (nextIndexRow+1)%groupSizeY==0}" :key="'nextSeatsDiv' + (nextIndexRow)"></div>
                      </template>
                    </transition-group>
                  </div>
                </template>
              </v-card>
            </v-col>


          <!-- 以下デバッグ用表示
          <v-row>
            <v-col cols="12">
              <h1 class="text-center">以下デバッグ用</h1>
            </v-col>
          </v-row>

          <v-row>
            <v-col cols="6">
              <p style="text-align: center">席替え後の座席</p>
              <template v-if="isRenderNextSeatsTable">
                <div class="center">
                  <transition-group name="transition-item" type="transition">
                    <template v-for="( nextSeats, nextIndexRow ) in nextSeatsTable" >
                      <template v-for="( nextSeat, nextIndexCol ) in nextSeats">
                        <span :id="'nextSeatsRow' + nextIndexRow + nextIndexCol" class="sortable-item transition-item square minus-margin-bottom" :key="uniqueKey(nextSeat, nextIndexRow, nextIndexCol)">
                          <textarea class="sortable-item"
                          :class="['seat', getColorByName(nextSeatsTable[nextIndexRow][nextIndexCol])]"
                          style="text-align: center;  resize: none; word-break: keep-all"
                          :value="nextSeatsTable[nextIndexRow][nextIndexCol]"
                          @input="testMethod2(nextIndexCol, nextIndexRow, $event.target.value )">
                          </textarea>
                        </span>
                        <span :class="{'margin-right': (nextIndexCol+1)%groupSizeX==0}" :key="'nextSeatsSpan' + (nextIndexRow*seatsSizeX+nextIndexCol)"></span>
                      </template>
                      <div :class="{'margin-bottom': (nextIndexRow+1)%groupSizeY==0}" :key="'nextSeatsDiv' + (nextIndexRow)"></div>
                    </template>
                  </transition-group>
                </div>
              </template>
            </v-col>
            <v-col cols="6">
              <v-row>
                <v-col cols="12" style="background-color: darkgray">
                  <v-btn elevation="2" outlined @click="testMethod1">テスト1</v-btn>
                  <v-btn elevation="2" outlined @click="testMethod2">テスト2</v-btn>
                  <v-btn elevation="2" outlined @click="testMethod3">テスト3</v-btn>
                </v-col>

                <v-col cols="6" style="background-color: khaki">
                  <p>有効な座席のインデックス配列</p>
                  {{ seatsTableIndex }}
                  <p>有効な座席のインデックス配列の複製</p>
                  {{ dupSeatsTableIndex }}
                </v-col>
                <v-col cols="6" style="background-color: paleturquoise">
                  <p>生徒の名前用配列</p>
                  {{ studentsName }}
                  <p>生徒の名前用配列の複製</p>
                  {{ dupStudentsName }}
                </v-col>
                <v-col cols="6" style="background-color: lightsteelblue">
                  <p>最前列の座席のインデックス配列</p>
                  {{ frontSeatsIndex }}
                  <p>最前列の座席のインデックス配列の複製</p>
                  {{ dupFrontSeatsIndex }}
                </v-col>
                <v-col cols="6" style="background-color: #edbee6">
                  <p>最後列の座席のインデックス配列</p>
                  {{ backSeatsIndex }}
                  <p>最後列の座席のインデックス配列の複製</p>
                  {{ dupBackSeatsIndex }}
                </v-col>
                <v-col cols="6" style="background-color: #ede7d5">
                  <p>前2列の座席のインデックス配列</p>
                  {{ frontTwoRowsSeatsIndex }}
                  <p>前2列の座席のインデックス配列の複製</p>
                  {{ dupFrontTwoRowsSeatsIndex }}
                </v-col>
                <v-col cols="6" style="background-color: #a3cccc">
                  <p>後ろ2列の座席のインデックス配列</p>
                  {{ backTwoRowsSeatsIndex }}
                  <p>後ろ2列の座席のインデックス配列の複製</p>
                  {{ dupBackTwoRowsSeatsIndex }}
                </v-col>
                <v-col cols="6"  style="background-color: lightsalmon">
                  <div>
                    <p>現在の座席記憶用テーブル</p>
                    <p v-for="seats in seatsTable">{{ seats }}</p>
                  </div>
                </v-col>
                <v-col cols="6"  style="background-color: palegreen">
                  <div>
                    <p>席替え後の座席記憶用テーブル</p>
                    <p v-for="nextSeats in nextSeatsTable">{{ nextSeats }}</p>
                  </div>
                </v-col>
                <v-col cols="6" style="background-color: plum">
                  <p>近づける条件用配列</p>
                  {{ nearConditions }}
                  <p>近づける名前用配列</p>
                  {{ nearStudentsName }}
                  <p>近づける名前用配列の複製</p>
                  {{ dupNearStudentsName }}
                </v-col>
                <v-col cols="6" style="background-color: lightcyan">
                  <p>離す条件用配列</p>
                  {{ farConditions }}
                  <p>離す条件用配列</p>
                  {{ farStudentsName }}
                  <p>離す条件用配列の複製</p>
                  {{ dupFarStudentsName }}
                </v-col>
                <v-col cols="6" style="background-color: palegreen">
                  <p>最前列に固定する生徒</p>
                  {{ frontConditions }}
                </v-col>
                <v-col cols="6" style="background-color: #b1a6ed">
                  <p>最後列に固定する生徒</p>
                  {{ backConditions }}
                </v-col>
                <v-col cols="6" style="background-color: #ede7d5">
                  <p>前2列に固定する生徒</p>
                  {{ frontTwoRowsConditions }}
                </v-col>
                <v-col cols="6" style="background-color: #a3cccc">
                  <p>後ろ2列に固定する生徒</p>
                  {{ backTwoRowsConditions }}
                </v-col>
                <v-col cols="6" style="background-color: aliceblue">
                  <p>性別用テーブル</p>
                  <p v-for="seats in genderTable">{{ seats }}</p>
                </v-col>
                <v-col cols="6" style="background-color: #faf2c8">
                  <p>性別用配列</p>
                  {{ genderArray }}
                </v-col>
                <v-col cols="6" style="background-color: plum">
                  <p>固定する条件用配列</p>
                  {{ fixConditions }}
                </v-col>
                <v-col cols="6" style="background-color: #b1a6ed">
                  <p>disabledStudentsName</p>
                  {{ disabledStudentsName }}
                </v-col>
              </v-row>
            </v-col-->
          </v-row>
        </v-container>
      </v-app>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js"></script>

    <script>
      // sortableJSで使う変数、sortableJSではVueのdataやmethodを認識しないため
      let isReverseSeats = false; // スワップした座席を席替え直前に戻すためのフラグ
      let fromRows = [];
      let fromCols = [];
      let toRows = [];
      let toCols = [];
      Array.prototype.originalIndexOf = function(target) { // indexOf()は厳密比較を行うため、抽象比較を行うメソッドを定義
        let indexNum = this.length;
        let dupThis = this.slice(0); // reverse()は破壊的なので、引数を破壊しないために複製を作成
        let temp = dupThis.reverse().some(array => {
          indexNum -= 1;
          return (array.toString() == target.toString()); // 配列を比較するときは厳密比較になるので文字列に変換
        })
        if(!temp){ indexNum -= 1; } // 最後まで見つからなかったとき、返り値を-1にするための調整
        return indexNum;
      };
      const app = new Vue({
        el: "#app",
        vuetify: new Vuetify({
          light: {
            primary: '#3f51b5',
            secondary: '#b0bec5',
            accent: '#8c9eff',
            error: '#b71c1c',
          },
        }),
        data: {
          seatsSizeY: 6, // デフォルト値は6
          seatsSizeX: 6, // デフォルト値は6
          seatsTable: [], // 座席テーブル
          seatsTableIndex: [], // 座席テーブル上の有効な座席のインデックス
          dupSeatsTableIndex: [], // 座席テーブル上の有効な座席のインデックスの複製、席替えの際に破壊的にデータを取り出していく
          seatsNum: 0, // 有効な座席数
          seatsOptionsX: [1,2,3,4,5,6,7,8], // よこの座席数入力フォームの選択肢
          seatsOptionsY: [1,2,3,4,5,6,7,8], // たての座席数入力フォームの選択肢
          limitedSeatsOptionsX: [1,2,3,4,5,6], // seatsSizeXのデフォルト値6に合わせて、選択肢のデフォルト値も6までにする
          limitedSeatsOptionsY: [1,2,3,4,5,6], // seatsSizeYのデフォルト値6に合わせて、選択肢のデフォルト値も6までにする
          distanceOptions: [0,1,2,3,4], // 近づける・離す距離の選択肢、デフォルト値6に合わせて実現可能な選択肢をデフォルトに設定
          studentsName: [], // 生徒の名前配列、席替えボタンが2回以上押されたときに元の生徒名を記憶しておくため
          dupStudentsName: [], // 生徒の名前配列の複製、席替えの際に破壊的にデータを取り出していく
          nearConditions: [['', '', '']], // 近づける条件配列
          nearStudentsName: [], // 近づける生徒の名前
          dupNearStudentsName: [], // 近づける生徒の名前の複製
          farConditions: [['', '', '']], // 離す条件用配列
          farStudentsName: [], // 離す生徒の名前
          dupFarStudentsName: [], // 離す生徒の名前の複製
          nearFarStudentsName: [], // 近づける/離す生徒の名前
          dupNearFarStudentsName: [], // 近づける/離す生徒の名前の複製
          frontConditions: [''], // 最前列に固定する生徒
          frontSeatsIndex: [], // 最前列のインデックス
          dupFrontSeatsIndex: [], // 最前列のインデックスの複製、席替えの際に破壊的にデータを取り出していく
          frontTwoRowsConditions: [''], // 前2列に固定する生徒
          frontTwoRowsSeatsIndex: [], // 前2列のインデックス
          dupFrontTwoRowsSeatsIndex: [], // 前2列のインデックスの複製、席替えの際に破壊的にデータを取り出していく
          backConditions: [''], // 最後列に固定する生徒
          backSeatsIndex: [], // 最後列のインデックス
          dupBackSeatsIndex: [], // 最前列のインデックスの複製、席替えの際に破壊的にデータを取り出していく
          backTwoRowsConditions: [''], // 後ろ2列に固定する生徒
          backTwoRowsSeatsIndex: [], // 後ろ2列のインデックス
          dupBackTwoRowsSeatsIndex: [], // 後ろ2列のインデックスの複製、席替えの際に破壊的にデータを取り出していく
          nextSeatsTable: [], // 席替え後の座席テーブル
          tempRow: '', // 2次元配列をリアクティブに更新するために、2次元配列の要素である1次元配列を退避
          calcNum: 0, // 計算回数、無限ループに入ったときに抜け出す用
          restartFlag: false, // 条件を満たしていないとき、changeSeats()の最初からリスタートする制御用フラグ
          genderTable: [], // 生徒の性別テーブル
          genderArray: [], // 生徒の性別配列、テーブルを展開したもの、studentsName[]と順番が対応
          isAllDifferent: false, // 前回の座席と異なる配置にするかどうかの制御フラグ
          isFixGender: false, // 性別を固定するかどうかの制御フラグ
          fixConditions: [['', '', '']], // 近づける条件配列
          disabledStudentsName: [], // 選択肢の中でdisableにする生徒名
          groupSizeX: 2,
          groupSizeY: 3,
          groupSizeOptionsX: ['なし',2,3],
          groupSizeOptionsY: ['なし',2,3],
          isRenderNextSeatsTable: true, // nextSeatsTableを表示するかどうかの制御フラグ
          drawer: true,
        },
        methods: {
          testMethod1() { // デバッグ用。最後に消す。
          },
          testMethod2() { // 引数で受け取った座席の有効・無効を切り替える
          },
          testMethod3() {
            console.log(`fromRows = ${fromRows}`);
            console.log(`fromCols = ${fromCols}`);
            console.log(`toRows = ${toRows}`);
            console.log(`toCols = ${toCols}`);
          },
          uniqueKey(value, nextIndexRow, nextIndexCol) {
            let key
            if(value == ''){
              key = `nextSeatsRow${nextIndexRow*this.seatsSizeX + nextIndexCol}`;
            }else{
              key = value;
            }
            return key;
          },
          beforeChangeSeats() { // トランジションのズレをなくすために、スワップされていたら席替え直前に、次の座席テーブルに反映する
            if(isReverseSeats){
              this.reverseSeats();
              this.isRenderNextSeatsTable = false; // 描画を一度オフにして、
              this.$nextTick(function(){ // DOMに反映されるのを待ち、
                this.isRenderNextSeatsTable = true; // 描画をオンにする
              });
            }
            isReverseSeats = false;
          },
          delayChangeSeats() { // beforeChangeSeats()の反映を待つために、わずかに遅れてChangeSeats()を呼び出す
            setTimeout(this.changeSeats,1);
          },
          createNewNearConditions(){
            this.nearConditions.push(['', '', '']);
          },
          createNewFarConditions(){
            this.farConditions.push(['', '', '']);
          },
          createNewFixConditions(){
            this.fixConditions.push(['', '', '']);
          },
          createNewFrontConditions(){
            if(this.frontConditions.length < this.seatsSizeX){
              this.frontConditions.push('');
            }
          },
          createNewFrontTwoRowsConditions(){
            if(this.frontTwoRowsConditions.length < this.seatsSizeX * 2){
              this.frontTwoRowsConditions.push('');
            }
          },
          createNewBackTwoRowsConditions(){
            if(this.backTwoRowsConditions.length < this.seatsSizeX * 2){
              this.backTwoRowsConditions.push('');
            }
          },
          createNewBackConditions(){
            if(this.backConditions.length < this.seatsSizeX){
              this.backConditions.push('');
            }
          },
          getColorByName(studentName) { // 座席の種類に応じた色を返す
            let genderIndex = this.studentsName.indexOf(studentName); // 生徒名に対応する性別を取得
            let gender
            if(genderIndex === -1){ //
              gender = ''
            }else{
              gender = this.genderArray[genderIndex];
            }
            if(gender === '') {
              return 'off-seats'
            }else if(gender === 'male'){
              return 'male-seats'
            }else if(gender === 'female'){
              return 'female-seats'
            }else return 'on-seats'
          },
          toggleGender(col, row) {
            if(this.genderTable[row][col] === 'male'){
              this.genderTable[row].splice(col, 1, 'female')
            }else if(this.genderTable[row][col] === 'female'){
              this.genderTable[row].splice(col, 1, 'male')
            }
          },
          writeStudentName(indexCol, indexRow, name) { // 引数で受け取った座席の有効・無効を切り替える
            this.seatsTable[indexRow].splice(indexCol, 1, name)
            if(this.genderTable[indexRow][indexCol] === ''){
              this.genderTable[indexRow].splice(indexCol, 1, 'male')
            }
          },
          makeSeatsTable() { // seatsTableを作成
            this.seatsTable.splice(0)
            for(let i = 0; i < this.seatsSizeY; i++) {
              this.seatsTable.push( Array(this.seatsSizeX).fill('') ) // すべての席に名前が未入力な状態でテーブルを作成
            }
            this.countSeats();
          },
          countSeats() { // 有効な座席数をカウント
            this.seatsNum = 0;
            this.seatsTable.forEach(seatsRow => {
              seatsRow.forEach(seat => {
                if (seat !== '') this.seatsNum += 1
              })
            })
          },
          makeNextSeatsTable() { // nextSeatsTableを作成
            this.nextSeatsTable.splice(0)
            for(let i = 0; i < this.seatsSizeY; i++) {
              this.nextSeatsTable.push( Array(this.seatsSizeX).fill('') ) // すべての席に名前が未入力な状態でテーブルを作成
            }
          },
          resetNextSeatsTable() { // nextSeatsTableを空白で初期化
            for(let i = 0; i < this.seatsSizeY; i++) {
              this.nextSeatsTable.splice(i, 1, Array(this.seatsSizeX).fill(''));
            }
          },
          changeSeats() { // メイン処理
            let loopNum = 0; // changeSeats()の処理を指定された回数繰り返す際に制御する変数
            do {
              loopNum += 1;
              console.log(`----${loopNum}回目のループを開始します----`);
              this.restartFlag = false;
              this.calcNum = 0 // エラー用計算量を初期化
              this.resetNextSeatsTable(); // 席替え後座席テーブルを初期化する
              this.resetFrontSeatsIndex(); // 最前列インデックス配列を空にする
              this.resetFrontTwoRowsSeatsIndex(); // 前2列インデックス配列を空にする
              this.resetBackSeatsIndex(); // 最後列インデックス配列を空にする
              this.resetBackTwoRowsSeatsIndex(); // 後ろ2列インデックス配列を空にする
              //this.makeSeatsTable();                                                                  //test
              //this.makeNextSeatsTable();                                                              // test
              this.makeFrontSeatsIndex(); // 最前列インデックスを作成
              this.makeFrontTwoRowsSeatsIndex(); // 前2列インデックスを作成
              this.makeBackSeatsIndex(); // 最後列インデックスを作成
              this.makeBackTwoRowsSeatsIndex(); // 後ろ2列インデックスを作成
              this.frontConditions = this.frontConditions.filter(Boolean); // 空白を削除
              this.frontTwoRowsConditions = this.frontTwoRowsConditions.filter(Boolean); // 空白を削除
              this.backConditions = this.backConditions.filter(Boolean); // 空白を削除
              this.backTwoRowsConditions = this.backTwoRowsConditions.filter(Boolean); // 空白を削除
              this.dupSeatsTableIndex = this.seatsTableIndex.slice(0); // 有効な座席のインデックスを複製、席替えの際にこの配列から破壊的にデータを取り出していく
              this.dupFrontSeatsIndex = this.frontSeatsIndex.slice(0); // 最前列の座席のインデックスを複製、席替えの際にこの配列から破壊的にデータを取り出していく
              this.dupFrontTwoRowsSeatsIndex = this.frontTwoRowsSeatsIndex.slice(0); // 前2列の座席のインデックスを複製、席替えの際にこの配列から破壊的にデータを取り出していく
              this.dupBackSeatsIndex = this.backSeatsIndex.slice(0); // 最後列の座席のインデックスを複製、席替えの際にこの配列から破壊的にデータを取り出していく
              this.dupBackTwoRowsSeatsIndex = this.backTwoRowsSeatsIndex.slice(0); // 後ろ2列の座席のインデックスを複製、席替えの際にこの配列から破壊的にデータを取り出していく
              this.dupStudentsName = this.studentsName.slice(0); // 生徒名を複製、席替えの際にこの配列から破壊的にデータを取り出していく
              //this.dupNearStudentsName = this.nearStudentsName.slice(0); // 近づける生徒名を複製、席替えの際にこの配列から破壊的にデータを取り出していく
              //this.dupFarStudentsName = this.farStudentsName.slice(0); // 離す生徒名を複製、席替えの際にこの配列から破壊的にデータを取り出していく
              this.dupNearFarStudentsName = this.nearStudentsName.concat(this.farStudentsName); // 近づける生徒名と離す生徒名を結合、席替えの際にこの配列から破壊的にデータを取り出していく
              this.dupNearFarStudentsName = Array.from(new Set(this.dupNearFarStudentsName)) // 重複している名前を削除

              this.placeFixedSeats(); // 固定する生徒を配置
              this.changeFrontSeats(); // 最前列に固定する生徒を席替え
              this.changeBackSeats(); // 最後列に固定する生徒を席替え
              this.changeFrontTwoRowsSeats(); // 前2列に固定する生徒を席替え
              this.changeBackTwoRowsSeats(); // 後ろ2列に固定する生徒を席替え
              //this.changeNearSeats(); // 近づける生徒を席替え
              //this.changeFarSeats(); // 離す生徒を席替え
              this.changeNearFarSeats(); // 近づける/離す生徒を席替え
              this.shuffleSeats(); // 条件のない生徒を席替え

              this.createNewFrontConditions(); // 次回の準備、最前列のフォームを1つ作成
              this.createNewFrontTwoRowsConditions(); // 次回の準備、前2列のフォームを1つ作成
              this.createNewBackTwoRowsConditions(); // 次回の準備、後2列のフォームを1つ作成
              this.createNewBackConditions(); // 次回の準備、最後列のフォームを1つ作成
              console.log(`----${loopNum}回目のループ終了----`);
            } while(this.restartFlag && loopNum <= 500)
            this.$nextTick(function(){ // DOMの更新を待ってからsortableJSをフォームにセット
              setTimeout(this.setSortableJS, 100); // setTimeout()で処理しないとセットされない
            });
            console.log(`====終了====`);
            if(loopNum > 500){
              window.alert('条件を満たす席替えを実現できませんでした。\n何回か試してもエラーが出るようでしたら、条件を変更してください。');
            }
          },
          pushSeatsTableIndex(indexCol, indexRow) { // 座席テーブルの有効な座席のインデックスをプッシュ
            this.seatsTableIndex.push([indexCol, indexRow]);
          },
          shuffleSeats() { // 条件のない生徒を席替え
            this.shuffle(this.dupSeatsTableIndex); // インデックスをシャッフル
            this.dupStudentsName.forEach(dupStudentName => { // 生徒を一人取り出す
              let topIndex = this.dupSeatsTableIndex.shift(); // シャッフルしたインデックスを格納した配列の先頭を取り出す
              while( (this.isFixGender && !this.checkGender(dupStudentName, topIndex)) || (this.isAllDifferent && !this.checkDifferent(dupStudentName, topIndex)) ){ // 条件を満たさない間、繰り返す
                if(this.calcNum > this.seatsNum){
                  this.restartFlag = true;
                  break;
                }
                this.dupSeatsTableIndex.push(topIndex); // 取り出したインデックスを配列の最後にプッシュして
                topIndex = this.dupSeatsTableIndex.shift(); // 配列先頭のインデックスを再度取り出す
                this.calcNum += 1;
              }
              this.nextSeatsTable[topIndex[1]].splice(topIndex[0], 1, dupStudentName); // 取り出したインデックスの位置に生徒名を保存
            })
          },
          shuffle(array) { // 配列をランダムにシャッフル
            for (let i = array.length - 1; i >= 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              const tempValue = array[i];
              array.splice(i, 1, array[j]);
              array.splice(j, 1, tempValue);
            }
          },
          makeFrontSeatsIndex() {
            this.seatsTableIndex.forEach(indexArray => {
              if(indexArray[1] === 0) { // 最前列なら
                this.frontSeatsIndex.push(indexArray); // 最前列インデックス配列にインデックスをプッシュ
              }
            })
          },
          resetFrontSeatsIndex() { // 最前列インデックス配列を空にする
            this.frontSeatsIndex.splice(0);
          },
          makeFrontTwoRowsSeatsIndex() {
            this.seatsTableIndex.forEach(indexArray => {
              if(indexArray[1] <= 1) { // 前2列なら
                this.frontTwoRowsSeatsIndex.push(indexArray); // 最前列インデックス配列にインデックスをプッシュ
              }
            })
          },
          resetFrontTwoRowsSeatsIndex() { // 前2列インデックス配列を空にする
            this.frontTwoRowsSeatsIndex.splice(0);
          },
          makeBackSeatsIndex() {
            this.seatsTableIndex.forEach(indexArray => {
              if(indexArray[1] === this.seatsSizeY-1) { // 最後列なら
                this.backSeatsIndex.push(indexArray); // 最後列インデックス配列にインデックスをプッシュ
              }
            })
          },
          resetBackSeatsIndex() { // 最後列インデックス配列を空にする
            this.backSeatsIndex.splice(0);
          },
          makeBackTwoRowsSeatsIndex() {
            this.seatsTableIndex.forEach(indexArray => {
              if(indexArray[1] >= this.seatsSizeY-2) { // 後ろ2列なら
                this.backTwoRowsSeatsIndex.push(indexArray); // 後ろ2列インデックス配列にインデックスをプッシュ
              }
            })
          },
          resetBackTwoRowsSeatsIndex() { // 後ろ2列インデックス配列を空にする
            this.backTwoRowsSeatsIndex.splice(0);
          },
          changeFrontSeats() { // 最前列に固定する生徒を席替え
            this.shuffle(this.dupFrontSeatsIndex);
            this.frontConditions.forEach(frontStudentName => {
              let topIndex = this.dupFrontSeatsIndex.shift(); // シャッフルしたインデックスを格納した配列の先頭を取り出す
              // ----近づける/離す/性別/異なる座席チェック----
              while( !this.checkNear(frontStudentName, topIndex) || !this.checkFar(frontStudentName, topIndex) || ( this.isFixGender && !this.checkGender(frontStudentName, topIndex)) || (this.isAllDifferent && !this.checkDifferent(frontStudentName, topIndex)) ){ // いずれかの条件を満たさない間、繰り返す
                if(this.calcNum > this.seatsNum){
                  this.restartFlag = true;
                  break;
                }
                this.dupFrontSeatsIndex.push(topIndex); // 取り出したインデックスを配列の最後にプッシュして
                topIndex = this.dupFrontSeatsIndex.shift(); // 配列先頭のインデックスを再度取り出す
                this.calcNum += 1;
              }
              // ----ここまで----
              this.nextSeatsTable[topIndex[1]].splice(topIndex[0], 1, frontStudentName); // 取り出したインデックスの位置に生徒名を保存
              this.delete(topIndex, this.dupSeatsTableIndex); // ここで配置した生徒はshuffleSeats()で配置する必要がないため、有効な座席座標を削除する
              this.delete(frontStudentName, this.dupStudentsName); // ここで配置した生徒はshuffleSeats()で配置する必要がないため、生徒名を削除する
              this.delete(frontStudentName, this.dupNearFarStudentsName); // ここで配置した生徒はchangeNearFarSeats()で配置する必要がないため、生徒名を削除する
              this.delete(topIndex, this.dupFrontTwoRowsSeatsIndex); // ここで配置した座標はchangeFrontTwoRowsSeats()で使えないため、座席座標を削除する
            })
          },
          changeFrontTwoRowsSeats() { // 前2列に固定する生徒を席替え
            this.shuffle(this.dupFrontTwoRowsSeatsIndex);
            this.frontTwoRowsConditions.forEach(frontTwoRowsStudentName => {
              let topIndex = this.dupFrontTwoRowsSeatsIndex.shift(); // シャッフルしたインデックスを格納した配列の先頭を取り出す
              // ----近づける/離す/性別/異なる座席チェック----
              while( !this.checkNear(frontTwoRowsStudentName, topIndex) || !this.checkFar(frontTwoRowsStudentName, topIndex) || ( this.isFixGender && !this.checkGender(frontTwoRowsStudentName, topIndex)) || (this.isAllDifferent && !this.checkDifferent(frontTwoRowsStudentName, topIndex)) ){ // いずれかの条件を満たさない間、繰り返す
                if(this.calcNum > this.seatsNum){
                  this.restartFlag = true;
                  break;
                }
                this.dupFrontTwoRowsSeatsIndex.push(topIndex); // 取り出したインデックスを配列の最後にプッシュして
                topIndex = this.dupFrontTwoRowsSeatsIndex.shift(); // 配列先頭のインデックスを再度取り出す
                this.calcNum += 1;
              }
              // ----ここまで----
              this.nextSeatsTable[topIndex[1]].splice(topIndex[0], 1, frontTwoRowsStudentName); // 取り出したインデックスの位置に生徒名を保存
              this.delete(topIndex, this.dupSeatsTableIndex); // ここで配置した生徒はshuffleSeats()で配置する必要がないため、有効な座席座標を削除する
              this.delete(frontTwoRowsStudentName, this.dupStudentsName); // ここで配置した生徒はshuffleSeats()で配置する必要がないため、生徒名を削除する
              this.delete(frontTwoRowsStudentName, this.dupNearFarStudentsName); // ここで配置した生徒はchangeNearFarSeats()で配置する必要がないため、生徒名を削除する
            })
          },
          changeBackSeats() { // 最後列に固定する生徒を席替え
            this.shuffle(this.dupBackSeatsIndex);
            this.backConditions.forEach(backStudentName => {
              let topIndex = this.dupBackSeatsIndex.shift(); // シャッフルしたインデックスを格納した配列の先頭を取り出す
              // ----近づける/離す/性別/異なる座席チェック----
              while( !this.checkNear(backStudentName, topIndex) || !this.checkFar(backStudentName, topIndex) || ( this.isFixGender && !this.checkGender(backStudentName, topIndex)) || (this.isAllDifferent && !this.checkDifferent(backStudentName, topIndex)) ){ // いずれかの条件を満たさない間、繰り返す
                if(this.calcNum > this.seatsNum){
                  this.restartFlag = true;
                  break;
                }
                this.dupBackSeatsIndex.push(topIndex); // 取り出したインデックスを配列の最後にプッシュして
                topIndex = this.dupBackSeatsIndex.shift(); // 配列先頭のインデックスを再度取り出す
                this.calcNum += 1;
              }
              // ----ここまで----
              this.nextSeatsTable[topIndex[1]].splice(topIndex[0], 1, backStudentName); // 取り出したインデックスの位置に生徒名を保存
              this.delete(topIndex, this.dupSeatsTableIndex); // ここで配置した生徒はshuffleSeats()で配置する必要がないため、有効な座席座標を削除する
              this.delete(backStudentName, this.dupStudentsName); // ここで配置した生徒はshuffleSeats()で配置する必要がないため、生徒名を削除する
              this.delete(backStudentName, this.dupNearFarStudentsName); // ここで配置した生徒はchangeNearFarSeats()で配置する必要がないため、生徒名を削除する
              this.delete(topIndex, this.dupBackTwoRowsSeatsIndex); // ここで配置した座標はchangeBackTwoRowsSeats()で使えないため、座席座標を削除する
            })
          },
          changeBackTwoRowsSeats() { // 後ろ2列に固定する生徒を席替え
            this.shuffle(this.dupBackTwoRowsSeatsIndex);
            this.backTwoRowsConditions.forEach(backTwoRowsStudentName => {
              if(!this.dupBackTwoRowsSeatsIndex.length){
                // todo エラーを表示してbreak
              }
              let topIndex = this.dupBackTwoRowsSeatsIndex.shift(); // シャッフルしたインデックスを格納した配列の先頭を取り出す
              // ----近づける/離す/性別/異なる座席チェック----
              while( !this.checkNear(backTwoRowsStudentName, topIndex) || !this.checkFar(backTwoRowsStudentName, topIndex) || ( this.isFixGender && !this.checkGender(backTwoRowsStudentName, topIndex)) || (this.isAllDifferent && !this.checkDifferent(backTwoRowsStudentName, topIndex)) ){ // いずれかの条件を満たさない間、繰り返す
                if(this.calcNum > this.seatsNum){
                  this.restartFlag = true;
                  break;
                }
                this.dupBackTwoRowsSeatsIndex.push(topIndex); // 取り出したインデックスを配列の最後にプッシュして
                topIndex = this.dupBackTwoRowsSeatsIndex.shift(); // 配列先頭のインデックスを再度取り出す
                this.calcNum += 1;
              }
              // ----ここまで----
              this.nextSeatsTable[topIndex[1]].splice(topIndex[0], 1, backTwoRowsStudentName); // 取り出したインデックスの位置に生徒名を保存
              this.delete(topIndex, this.dupSeatsTableIndex); // ここで配置した生徒はshuffleSeats()で配置する必要がないため、有効な座席座標を削除
              this.delete(backTwoRowsStudentName, this.dupStudentsName); // ここで配置した生徒はshuffleSeats()で配置する必要がないため、生徒名を削除
              this.delete(backTwoRowsStudentName, this.dupNearFarStudentsName); // ここで配置した生徒は、changeNearFarSeats()で配置する必要がないため、生徒名を削除する
            })
          },
          /*
          changeNearSeats() { // 近づける生徒を席替え
            this.shuffle(this.dupSeatsTableIndex);
            this.dupNearStudentsName.forEach(dupNearStudentName => {
              let topIndex = this.dupSeatsTableIndex.shift(); // シャッフルしたインデックスを格納した配列の先頭を取り出す
              //console.log(`${dupNearStudentName} を ${topIndex} に入れるのは ${this.checkNear(dupNearStudentName, topIndex)} (${this.calcNum}回目の計算)`);
              // ----近づける処理----
              console.log(`dupNearStudentsName = ${this.dupNearStudentsName}`)
              while( !this.checkNear(dupNearStudentName, topIndex) ){ // 条件を満たさない間、繰り返す
                if(this.calcNum > 100){
                  window.alert('条件を満たす席替えを実現できませんでした。\n何回か試してもエラーが出るようでしたら、条件を変更してください。');
                  throw '計算量が100を超えました'
                }
                this.dupSeatsTableIndex.push(topIndex); // 取り出したインデックスを配列の最後にプッシュして
                topIndex = this.dupSeatsTableIndex.shift(); // 配列先頭のインデックスを再度取り出す
                // console.log(`${dupNearStudentName} を ${topIndex} に入れるのは ${this.checkNear(dupNearStudentName, topIndex)} (while内${this.calcNum}回目の計算)`);
                this.calcNum += 1;
              }
              // ----ここまで----
              this.nextSeatsTable[topIndex[1]].splice(topIndex[0], 1, dupNearStudentName); // 取り出したインデックスの位置に生徒名を保存

              let deleteStudentNameIndex = this.dupStudentsName.indexOf(dupNearStudentName); // changeNearSeats()で配置した生徒は、shuffleSeats()で配置する必要がないため
              this.dupStudentsName.splice(deleteStudentNameIndex, 1); // dupStudentsNameから削除する
              console.log(`${dupNearStudentName}を配置した`)

              let deleteFarStudentNameIndex = this.dupFarStudentsName.indexOf(dupNearStudentName); // changeNearSeats()で配置した生徒は、changeFarSeats()で配置する必要がないため
              if(deleteFarStudentNameIndex != -1){ // dupFarStudentsNameにあれば削除する
                this.dupFarStudentsName.splice(deleteFarStudentNameIndex, 1); // dupFarStudentsNameから削除する
              }
            })
          },
          */
          /*
          changeFarSeats() { // 離す生徒を席替え
            this.shuffle(this.dupSeatsTableIndex);
            this.dupFarStudentsName.forEach(dupFarStudentName => {
              let topIndex = this.dupSeatsTableIndex.shift(); // シャッフルしたインデックスを格納した配列の先頭を取り出す
              //console.log(`${dupNearStudentName} を ${topIndex} に入れるのは ${this.checkNear(dupNearStudentName, topIndex)} (${this.calcNum}回目の計算)`);
              // ----離す処理----
              console.log(`dupFarStudentsName = ${this.dupFarStudentsName}`)
              while( !this.checkFar(dupFarStudentName, topIndex) ){ // 条件を満たさない間、繰り返す
                if(this.calcNum > 100){
                  window.alert('条件を満たす席替えを実現できませんでした。\n何回か試してもエラーが出るようでしたら、条件を変更してください。');
                  throw '計算量が100を超えました'
                }
                this.dupSeatsTableIndex.push(topIndex); // 取り出したインデックスを配列の最後にプッシュして
                topIndex = this.dupSeatsTableIndex.shift(); // 配列先頭のインデックスを再度取り出す
                console.log(`${dupFarStudentName} を ${topIndex} に入れるのは ${this.checkFar(dupFarStudentName, topIndex)} (while内${this.calcNum}回目の計算)`);
                this.calcNum += 1;
              }
              // ----ここまで----
              this.nextSeatsTable[topIndex[1]].splice(topIndex[0], 1, dupFarStudentName); // 取り出したインデックスの位置に生徒名を保存

              let deleteStudentNameIndex = this.dupStudentsName.indexOf(dupFarStudentName); // changeNearSeats()で配置した生徒は、shuffleSeats()で配置する必要がないため
              this.dupStudentsName.splice(deleteStudentNameIndex, 1); // dupStudentsNameから削除する
              console.log(`${dupFarStudentName}を配置した`)
            })
          },
          */
          changeNearFarSeats() { // 近づける/離す生徒を席替え
            this.shuffle(this.dupSeatsTableIndex);
            this.dupNearFarStudentsName.forEach(dupNearFarStudentName => {
              let topIndex = this.dupSeatsTableIndex.shift(); // シャッフルしたインデックスを格納した配列の先頭を取り出す
              // ----近づける/離す/性別/異なる座席チェック----
              while( !this.checkNear(dupNearFarStudentName, topIndex) || !this.checkFar(dupNearFarStudentName, topIndex) || (this.isFixGender && !this.checkGender(dupNearFarStudentName, topIndex)) || (this.isAllDifferent && !this.checkDifferent(dupNearFarStudentName, topIndex)) ){ // いずれかの条件を満たさない間、繰り返す
                if(this.calcNum > this.seatsNum){
                  this.restartFlag = true;
                  break;
                }
                this.dupSeatsTableIndex.push(topIndex); // 取り出したインデックスを配列の最後にプッシュして
                topIndex = this.dupSeatsTableIndex.shift(); // 配列先頭のインデックスを再度取り出す
                this.calcNum += 1;
              }
              // ----ここまで----
              this.nextSeatsTable[topIndex[1]].splice(topIndex[0], 1, dupNearFarStudentName); // 取り出したインデックスの位置に生徒名を保存
              this.delete(dupNearFarStudentName, this.dupStudentsName); // ここで配置した生徒はshuffleSeats()で配置する必要がないため、生徒名を削除する
            })
          },
          placeFixedSeats() { // 固定する生徒を配置
            this.fixConditions.forEach(fixCondition => {
              if(fixCondition[0] != ''){ // フォーム表示のため最後に['', '', '']が入ってしまっているので、そのときは処理しない
                let fixConditionName = fixCondition[0];
                let fixConditionRow = fixCondition[1]-1; // 入力された値とインデックスのずれを補正
                let fixConditionCol = fixCondition[2]-1; // 入力された値とインデックスのずれを補正
                this.nextSeatsTable[fixConditionRow].splice(fixConditionCol, 1, fixConditionName); // 固定する場所に配置

                let fixIndex = [fixConditionCol, fixConditionRow]
                this.delete(fixIndex, this.dupSeatsTableIndex); // ここで配置した生徒はshuffleSeats()で配置する必要がないため、有効な座席座標を削除する
                this.delete(fixConditionName, this.dupStudentsName); // ここで配置した生徒はshuffleSeats()で配置する必要がないため、生徒名を削除する
                this.delete(fixConditionName, this.dupNearFarStudentsName); // ここで配置した生徒はchangeNearFarSeats()で配置する必要がないため、生徒名を削除する

                this.delete(fixIndex, this.dupFrontSeatsIndex); // ここで配置した座標はchangeFrontSeats()で使えないため、座席座標を削除する
                this.delete(fixIndex, this.dupFrontTwoRowsSeatsIndex); // ここで配置した座標はchangeFrontTwoRowsSeats()で使えないため、座席座標を削除する
                this.delete(fixIndex, this.dupBackSeatsIndex); // ここで配置した座標はchangeBackSeats()で使えないため、座席座標を削除する
                this.delete(fixIndex, this.dupBackTwoRowsSeatsIndex); // ここで配置した座標はchangeBackTwoRowsSeats()で使えないため、座席座標を削除する
              }
            })
          },
          minDistance(p1, p2) { // 2点の距離のminを返す。p1, p2は座標、たとえばp1=[1,2]
            let x_abs = Math.abs( p1[0] - p2[0] );
            let y_abs = Math.abs( p1[1] - p2[1] );
            return Math.min(x_abs, y_abs);
          },
          maxDistance(p1, p2) { // 2点の距離のmaxを返す。p1, p2は座標、たとえばp1=[1,2]
            let x_abs = Math.abs( p1[0] - p2[0] );
            let y_abs = Math.abs( p1[1] - p2[1] );
            return Math.max(x_abs, y_abs);
          },
          checkNear(studentName, p) { // 引数の生徒を座標pに配置しても、近づける条件を満たすならtrue、満たさないならfalseを返す
            let return_value = true
            this.nearConditions.forEach(nearConditionArray => {
              if( nearConditionArray.includes(studentName) ){ // もし引数の生徒が、近づける条件にいれば
                // ----近づけたい生徒の名前を取得----
                let nearStudentName
                if( nearConditionArray.indexOf(studentName) == 0 ){
                  nearStudentName = nearConditionArray[1]; // 引数の生徒と近づけたい生徒
                }else if( nearConditionArray.indexOf(studentName) == 1 ){
                  nearStudentName = nearConditionArray[0]; // 引数の生徒と近づけたい生徒
                }
                // ----ここまで----
                let distance = nearConditionArray[2] + 1; // 距離、表記とのズレを修正するために+1
                let nearStudentPosition = this.getPositionFromNextSeatsTable(nearStudentName); // すでに配置されていればその座標、まだ配置されてなければfalse
                if( this.maxDistance(p, nearStudentPosition) > distance ){ // 距離のmaxが条件distanceより上なら返り値をfalseに更新
                  return_value = false;
                }
              }
            })
            return return_value;
          },
          checkFar(studentName, p) { // 引数の生徒を座標pに配置しても、離す条件を満たすならtrue、満たさないならfalseを返す
            let return_value = true
            this.farConditions.forEach(farConditionArray => {
              if( farConditionArray.includes(studentName) ){ // もし引数の生徒が、離す条件にいれば
                // ----離す生徒の名前を取得----
                let farStudentName
                if( farConditionArray.indexOf(studentName) == 0 ){
                  farStudentName = farConditionArray[1]; // 引数の生徒と離す生徒
                }else if( farConditionArray.indexOf(studentName) == 1 ){
                  farStudentName = farConditionArray[0]; // 引数の生徒と離す生徒
                }
                // ----ここまで----
                let distance = farConditionArray[2] + 1; // 距離、表記とのズレを修正するために+1
                let farStudentPosition = this.getPositionFromNextSeatsTable(farStudentName); // すでに配置されていればその座標、まだ配置されてなければfalse
                if( this.maxDistance(p, farStudentPosition) < distance ){ // 距離のminが条件distanceより下なら返り値をfalseに更新
                  return_value = false;
                }
              }
            })
            return return_value;
          },
          checkGender(studentName, p) { // 引数の生徒を座標pに配置したとき、性別の条件を満たすならtrue、満たさないならfalseを返す
            let genderIndex = this.studentsName.indexOf(studentName);
            let currentGender = this.genderArray[genderIndex]; // 引数の生徒の性別
            let nextGender = this.genderTable[p[1]][p[0]]; // 性別テーブルに記憶している性別
            if(currentGender === nextGender){
              return true
            }else{
              return false
            }
          },
          checkDifferent(studentName, p) { // 引数の生徒を座標pに配置したとき、現在の座席と異なっているならtrue、現在の座席と同じならfalseを返す
            let studentIndex = this.studentsName.indexOf(studentName);
            let currentIndex = this.seatsTableIndex[studentIndex];
            if(currentIndex.toString() == p.toString()) { // 配列を比較するときは厳密比較になるので文字列に変換
              return false;
            }else{
              return true;
            }
          },
          getPositionFromNextSeatsTable(studentName) { // 引数の生徒が席替え後座席テーブルにすでにいればその座標を、いなければfalseを返す
            let nextSeatsRowNum = 0; // 行インデックス、y座標
            let return_value = false; // 返す値の初期値をfalse
            this.nextSeatsTable.forEach(nextSeatsRow => {
              if( nextSeatsRow.includes(studentName) ){
                let nextSeatsColNum = nextSeatsRow.indexOf(studentName);
                return_value = [nextSeatsColNum, nextSeatsRowNum]; // 返す値を座標で更新
              }
              nextSeatsRowNum += 1;
            })
            return return_value;
          },
          makeGenderTable() { // genderTableを作成
            this.genderTable = []
            for(let i = 0; i < this.seatsSizeY; i++) {
              this.genderTable.push( Array(this.seatsSizeX).fill('') ) // すべての席に性別が未入力な状態でテーブルを作成
            }
          },
          delete(target, array){
            let deleteIndex = array.originalIndexOf(target); // 削除したいtargetがある配列arrayのインデックスを取得
            if(deleteIndex != -1){ // targetが配列arrayになければ返り値が-1となるので、そのときは削除しない
              array.splice(deleteIndex, 1); // arrayからtargetを削除する
            }
          },
          reverseSeats(){
            for(let i=0; i<fromRows.length; i++){
              let fromSeat = this.nextSeatsTable[fromRows[i]][fromCols[i]];
              let toSeat = this.nextSeatsTable[toRows[i]][toCols[i]];
              this.nextSeatsTable[fromRows[i]].splice(fromCols[i], 1, toSeat);
              this.nextSeatsTable[toRows[i]].splice(toCols[i], 1, fromSeat);
              console.log(`${fromSeat}([${fromRows[i]}][${fromCols[i]}])と${toSeat}([${toRows[i]}][${toCols[i]}])をスワップ`);
            }
            fromRows.splice(0);
            fromCols.splice(0);
            toRows.splice(0);
            toCols.splice(0);
          },
          setSortableJS(){ // sortableJSをフォームにセット
            for(let row=0; row<this.seatsSizeY; row++) {
              for(let col=0; col<this.seatsSizeX; col++) {
                let el = document.getElementById(`nextSeatsRow${row}${col}`);
                Sortable.create(el, {
                  group: "nextSeats",
                  swap: true,
                  swapClass: 'highlighted',
                  animation: 400,
                  onSort: function() { // スワップしたら、
                    isReverseSeats = true;
                  },
                  onEnd: function(evt) {
                    let fromRow = parseInt(evt.from.id.toString().slice(-2, -1));
                    let fromCol = parseInt(evt.from.id.toString().slice(-1));
                    let toRow = parseInt(evt.to.id.toString().slice(-2, -1));
                    let toCol = parseInt(evt.to.id.toString().slice(-1));
                    fromRows.push(fromRow);
                    fromCols.push(fromCol);
                    toRows.push(toRow);
                    toCols.push(toCol);
                  },
                });
              }
            }
          }
        },
        created() {
          this.makeSeatsTable(); // 最初にseatsTableを作成
          this.makeNextSeatsTable(); // 席替え後用のnextSeatsTableを空白で作成
          this.makeGenderTable(); // genderTableを作成
        },
        mounted() {
          this.setSortableJS(); // sortableJSをフォームにセット
        },
        watch: {
          seatsTable: {
            handler: function(){
              this.studentsName = Array.prototype.concat.apply([], this.seatsTable); //seatsTableを展開
              this.studentsName = this.studentsName.filter(function(studentName) { //空白を削除
                return studentName !== '';
              });
              this.seatsTableIndex.splice(0); // 有効な座席インデックス配列を初期化
              let row = 0;
              this.seatsTable.forEach(seats => {
                let col = 0;
                seats.forEach(seat => {
                  if(seat != ''){ // 更新されるごとに有効な座席を判定し、
                    this.seatsTableIndex.push([col, row]); // 有効な座席インデックス配列にプッシュ
                  }
                  if(seat == ''){ // 座席テーブルから名前が消されたら
                    this.genderTable[row].splice(col, 1, ''); // 性別も消去
                  }
                  col += 1;
                })
                row += 1;
              })
            },
            deep: true
          },
          nearConditions: {
            handler: function(){
              this.nearStudentsName.splice(-this.nearStudentsName.length); // 配列を初期化
              this.nearConditions.forEach( nearCondition => {
                this.nearStudentsName.push(nearCondition[0], nearCondition[1]);
              })
              this.nearStudentsName = Array.from(new Set(this.nearStudentsName)) // 重複している名前を削除
              this.nearStudentsName = this.nearStudentsName.filter(function(nearStudentsName) { //空白を削除
                return nearStudentsName !== '';
              })
            }
          },
          farConditions: {
            handler: function(){
              this.farStudentsName.splice(-this.farStudentsName.length); // 配列を初期化
              this.farConditions.forEach( farCondition => {
                this.farStudentsName.push(farCondition[0], farCondition[1]);
              })
              this.farStudentsName = Array.from(new Set(this.farStudentsName)) // 重複している名前を削除
              this.farStudentsName = this.farStudentsName.filter(function(farStudentsName) { //空白を削除
                return farStudentsName !== '';
              })
            }
          },
          genderTable: {
            handler: function(){
              this.genderArray = Array.prototype.concat.apply([], this.genderTable); //genderTableを展開
              this.genderArray = this.genderArray.filter(function(genderArray) { //空白を削除
                return genderArray !== '';
              })
            },
            deep: true
          },
          seatsSizeX: { // テーブルの横座席数が変わったら
            handler: function(){
              this.limitedSeatsOptionsX = [...Array(this.seatsSizeX)].map((_, i) => i + 1); // 固定する選択肢を変更
              const maxXY = Math.max(this.seatsSizeX, this.seatsSizeY);
              this.distanceOptions = [...Array(maxXY-1)].map((_, i) => i); // 距離の選択肢を変更
              this.makeSeatsTable(); // 現在の座席テーブルを新しい大きさで作り直す
              this.makeNextSeatsTable() // 次の座席テーブルを新しい大きさで作り直す
              this.makeGenderTable() // 性別テーブルを新しい大きさで作り直す
              switch(this.seatsSizeX) { // 班の大きさとデフォルト値を変更する
                case 1:
                  this.groupSizeOptionsX = ['なし'];
                  this.groupSizeX = 'なし'
                  break;
                case 2:
                  this.groupSizeOptionsX = ['なし'];
                  this.groupSizeX = 'なし'
                  break;
                case 3:
                  this.groupSizeOptionsX = ['なし'];
                  this.groupSizeX = 'なし'
                  break;
                case 4:
                  this.groupSizeOptionsX = ['なし', 2];
                  this.groupSizeX = 2
                  break;
                case 5:
                  this.groupSizeOptionsX = ['なし'];
                  this.groupSizeX = 'なし'
                  break;
                case 6:
                  this.groupSizeOptionsX = ['なし', 2, 3];
                  this.groupSizeX = 2
                  break;
                case 7:
                  this.groupSizeOptionsX = ['なし'];
                  this.groupSizeX = 'なし'
                  break;
                case 8:
                  this.groupSizeOptionsX = ['なし', 2, 4];
                  this.groupSizeX = 2
                  break;
              }
              this.$nextTick(function(){ // DOMの更新を待ってから
                this.setSortableJS(); // sortableJSをフォームにセット
              })
            }
          },
          seatsSizeY: { // テーブルの縦座席数が変わったら
            handler: function(){
              this.limitedSeatsOptionsY = [...Array(this.seatsSizeY)].map((_, i) => i + 1) // 固定する選択肢を変更
              const maxXY = Math.max(this.seatsSizeX, this.seatsSizeY);
              this.distanceOptions = [...Array(maxXY-1)].map((_, i) => i); // 距離の選択肢を変更
              this.makeSeatsTable(); // 現在の座席テーブルを新しい大きさで作り直す
              this.makeNextSeatsTable() // 次の座席テーブルを新しい大きさで作り直す
              this.makeGenderTable() // 性別テーブルを新しい大きさで作り直す
              switch(this.seatsSizeY) { // 班の大きさとデフォルト値を変更する
                case 1:
                  this.groupSizeOptionsY = ['なし'];
                  this.groupSizeY = 'なし'
                  break;
                case 2:
                  this.groupSizeOptionsY = ['なし'];
                  this.groupSizeY = 'なし'
                  break;
                case 3:
                  this.groupSizeOptionsY = ['なし'];
                  this.groupSizeY = 'なし'
                  break;
                case 4:
                  this.groupSizeOptionsY = ['なし', 2];
                  this.groupSizeY = 2
                  break;
                case 5:
                  this.groupSizeOptionsY = ['なし'];
                  this.groupSizeY = 'なし'
                  break;
                case 6:
                  this.groupSizeOptionsY = ['なし', 2, 3];
                  this.groupSizeY = 3
                  break;
                case 7:
                  this.groupSizeOptionsY = ['なし'];
                  this.groupSizeY = 'なし'
                  break;
                case 8:
                  this.groupSizeOptionsY = ['なし', 2, 4];
                  this.groupSizeY = 2
                  break;
              }
              this.$nextTick(function(){ // DOMの更新を待ってから
                this.setSortableJS(); // sortableJSをフォームにセット
              })
            }
          },
          frontConditions: {
            handler: function(){
              this.disabledStudentsName = this.frontConditions.concat(this.frontTwoRowsConditions, this.backTwoRowsConditions, this.backConditions);
              this.disabledStudentsName = this.disabledStudentsName.filter(Boolean); // 空白を削除
            }
          },
          frontTwoRowsConditions: {
            handler: function(){
              this.disabledStudentsName = this.frontConditions.concat(this.frontTwoRowsConditions, this.backTwoRowsConditions, this.backConditions);
              this.disabledStudentsName = this.disabledStudentsName.filter(Boolean); // 空白を削除
            }
          },
          backConditions: {
            handler: function(){
              this.disabledStudentsName = this.frontConditions.concat(this.frontTwoRowsConditions, this.backTwoRowsConditions, this.backConditions);
              this.disabledStudentsName = this.disabledStudentsName.filter(Boolean); // 空白を削除
            }
          },
          backTwoRowsConditions: {
            handler: function(){
              this.disabledStudentsName = this.frontConditions.concat(this.frontTwoRowsConditions, this.backTwoRowsConditions, this.backConditions);
              this.disabledStudentsName = this.disabledStudentsName.filter(Boolean); // 空白を削除
            }
          },
        },
        computed: {
          rowConditionsStudentsName() {
            return this.studentsName.map(studentName => {
              return {
                text: studentName,
                disabled: this.disabledStudentsName.includes(studentName)
              }
            })
          }
        }
      });
    </script>
  </body>
</html>
